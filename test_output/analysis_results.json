{
  "function_info": {
    "functions": [
      {
        "name": "divide_numbers",
        "args": [
          "a",
          "b"
        ],
        "docstring": "Divide two numbers with error handling\n\nArgs:\n    a (float): Numerator\n    b (float): Denominator\n\nReturns:\n    float: Result of division\n\nRaises:\n    ValueError: If denominator is zero\n    TypeError: If inputs are not numeric",
        "source_code": "def divide_numbers(a, b):\n    \"\"\"\n    Divide two numbers with error handling\n\n    Args:\n        a (float): Numerator\n        b (float): Denominator\n\n    Returns:\n        float: Result of division\n\n    Raises:\n        ValueError: If denominator is zero\n        TypeError: If inputs are not numeric\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numeric\")\n\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n\n    return a / b",
        "line_start": 1,
        "line_end": 22
      }
    ],
    "total_functions": 1,
    "source_code": "def divide_numbers(a, b):\n    \"\"\"\n    Divide two numbers with error handling\n\n    Args:\n        a (float): Numerator\n        b (float): Denominator\n\n    Returns:\n        float: Result of division\n\n    Raises:\n        ValueError: If denominator is zero\n        TypeError: If inputs are not numeric\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numeric\")\n\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n\n    return a / b"
  },
  "council_results": {
    "gemini-2.0-flash": {
      "raw_response": "```python\nimport pytest\n\ndef divide_numbers(a, b):\n    \"\"\"\n    Divide two numbers with error handling\n\n    Args:\n        a (float): Numerator\n        b (float): Denominator\n\n    Returns:\n        float: Result of division\n\n    Raises:\n        ValueError: If denominator is zero\n        TypeError: If inputs are not numeric\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numeric\")\n\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n\n    return a / b\n\ndef test_divide_numbers_positive_normal():\n    \"\"\"Test normal division with positive integers.\"\"\"\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should return correct quotient for positive integers\"\n\ndef test_divide_numbers_positive_float():\n    \"\"\"Test normal division with positive floats.\"\"\"\n    # Category: positive\n    result = divide_numbers(7.5, 2.5)\n    assert result == 3.0, \"Should return correct quotient for positive floats\"\n\ndef test_divide_numbers_negative_numerator():\n    \"\"\"Test division with a negative numerator.\"\"\"\n    # Category: positive\n    result = divide_numbers(-10, 2)\n    assert result == -5.0, \"Should handle negative numerator correctly\"\n\ndef test_divide_numbers_negative_denominator():\n    \"\"\"Test division with a negative denominator.\"\"\"\n    # Category: positive\n    result = divide_numbers(10, -2)\n    assert result == -5.0, \"Should handle negative denominator correctly\"\n\ndef test_divide_numbers_negative_both():\n    \"\"\"Test division with both negative numerator and denominator.\"\"\"\n    # Category: positive\n    result = divide_numbers(-10, -2)\n    assert result == 5.0, \"Should handle both negative numbers correctly\"\n\ndef test_divide_numbers_zero_numerator():\n    \"\"\"Test division with a zero numerator.\"\"\"\n    # Category: boundary\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should return 0 when numerator is 0\"\n\ndef test_divide_numbers_divide_by_zero():\n    \"\"\"Test division by zero, expecting a ValueError.\"\"\"\n    # Category: negative\n    with pytest.raises(ValueError) as excinfo:\n        divide_numbers(10, 0)\n    assert \"Cannot divide by zero\" in str(excinfo.value), \"Should raise ValueError for division by zero\"\n\ndef test_divide_numbers_invalid_input_type_string():\n    \"\"\"Test with string input, expecting a TypeError.\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(\"10\", 2)\n    assert \"Both arguments must be numeric\" in str(excinfo.value), \"Should raise TypeError for string input\"\n\ndef test_divide_numbers_invalid_input_type_list():\n    \"\"\"Test with list input, expecting a TypeError.\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(10, [1,2,3])\n    assert \"Both arguments must be numeric\" in str(excinfo.value), \"Should raise TypeError for list input\"\n\ndef test_divide_numbers_large_numbers():\n    \"\"\"Test division with large numbers\"\"\"\n    # Category: edge_case\n    result = divide_numbers(1e10, 2)\n    assert result == 5e9, \"Should handle large numbers correctly\"\n```",
      "test_methods": [
        {
          "name": "test_divide_numbers_positive_normal",
          "code": "def test_divide_numbers_positive_normal():\n    \"\"\"Test normal division with positive integers.\"\"\"\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should return correct quotient for positive integers\""
        },
        {
          "name": "test_divide_numbers_positive_float",
          "code": "def test_divide_numbers_positive_float():\n    \"\"\"Test normal division with positive floats.\"\"\"\n    # Category: positive\n    result = divide_numbers(7.5, 2.5)\n    assert result == 3.0, \"Should return correct quotient for positive floats\""
        },
        {
          "name": "test_divide_numbers_negative_numerator",
          "code": "def test_divide_numbers_negative_numerator():\n    \"\"\"Test division with a negative numerator.\"\"\"\n    # Category: positive\n    result = divide_numbers(-10, 2)\n    assert result == -5.0, \"Should handle negative numerator correctly\""
        },
        {
          "name": "test_divide_numbers_negative_denominator",
          "code": "def test_divide_numbers_negative_denominator():\n    \"\"\"Test division with a negative denominator.\"\"\"\n    # Category: positive\n    result = divide_numbers(10, -2)\n    assert result == -5.0, \"Should handle negative denominator correctly\""
        },
        {
          "name": "test_divide_numbers_negative_both",
          "code": "def test_divide_numbers_negative_both():\n    \"\"\"Test division with both negative numerator and denominator.\"\"\"\n    # Category: positive\n    result = divide_numbers(-10, -2)\n    assert result == 5.0, \"Should handle both negative numbers correctly\""
        },
        {
          "name": "test_divide_numbers_zero_numerator",
          "code": "def test_divide_numbers_zero_numerator():\n    \"\"\"Test division with a zero numerator.\"\"\"\n    # Category: boundary\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should return 0 when numerator is 0\""
        },
        {
          "name": "test_divide_numbers_divide_by_zero",
          "code": "def test_divide_numbers_divide_by_zero():\n    \"\"\"Test division by zero, expecting a ValueError.\"\"\"\n    # Category: negative\n    with pytest.raises(ValueError) as excinfo:\n        divide_numbers(10, 0)\n    assert \"Cannot divide by zero\" in str(excinfo.value), \"Should raise ValueError for division by zero\""
        },
        {
          "name": "test_divide_numbers_invalid_input_type_string",
          "code": "def test_divide_numbers_invalid_input_type_string():\n    \"\"\"Test with string input, expecting a TypeError.\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(\"10\", 2)\n    assert \"Both arguments must be numeric\" in str(excinfo.value), \"Should raise TypeError for string input\""
        },
        {
          "name": "test_divide_numbers_invalid_input_type_list",
          "code": "def test_divide_numbers_invalid_input_type_list():\n    \"\"\"Test with list input, expecting a TypeError.\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(10, [1,2,3])\n    assert \"Both arguments must be numeric\" in str(excinfo.value), \"Should raise TypeError for list input\""
        },
        {
          "name": "test_divide_numbers_large_numbers",
          "code": "def test_divide_numbers_large_numbers():\n    \"\"\"Test division with large numbers\"\"\"\n    # Category: edge_case\n    result = divide_numbers(1e10, 2)\n    assert result == 5e9, \"Should handle large numbers correctly\"\n```"
        }
      ],
      "test_count": 10
    },
    "gpt-5-mini": {
      "raw_response": "python\nimport math\nimport pytest\n\n# Note: These tests assume that the function divide_numbers is available in the test namespace.\n# If the function lives in another module, import it explicitly, for example:\n# from my_module import divide_numbers\n\ndef test_divide_integers_positive_case():\n    \"\"\"Test integer division returns correct quotient\"\"\"\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5, f\"Expected 10 / 2 to equal 5, got {result!r}\"\n\ndef test_divide_floats_positive_case():\n    \"\"\"Test float division returns correct floating-point result\"\"\"\n    # Category: positive\n    result = divide_numbers(7.5, 2.5)\n    assert math.isclose(result, 3.0, rel_tol=1e-12), f\"Expected 7.5 / 2.5 to be close to 3.0, got {result!r}\"\n\ndef test_divide_negative_numbers_positive_case():\n    \"\"\"Test dividing negative numbers (sign handling)\"\"\"\n    # Category: positive\n    result = divide_numbers(-9, -3)\n    assert result == 3, f\"Expected -9 / -3 to equal 3, got {result!r}\"\n\ndef test_divide_zero_numerator_boundary_case():\n    \"\"\"Test zero numerator returns zero (boundary case)\"\"\"\n    # Category: boundary\n    result = divide_numbers(0, 5)\n    # Division of 0 by non-zero should be 0.0 (float) or 0 (int). Normalize to float for comparison.\n    assert float(result) == 0.0, f\"Expected 0 / 5 to equal 0.0, got {result!r}\"\n\ndef test_divide_by_zero_raises_value_error_negative_case():\n    \"\"\"Test dividing by zero raises ValueError with expected message\"\"\"\n    # Category: negative\n    with pytest.raises(ValueError) as excinfo:\n        divide_numbers(1, 0)\n    assert str(excinfo.value) == \"Cannot divide by zero\", (\n        f\"Expected ValueError message 'Cannot divide by zero', got {str(excinfo.value)!r}\"\n    )\n\n@pytest.mark.parametrize(\"a,b\", [\n    (\"10\", 2),     # string numerator\n    (10, \"2\"),     # string denominator\n    (None, 1),     # None numerator\n    (1, None),     # None denominator\n    ([1,2], 2),    # list numerator\n    (1, {\"x\":1}),  # dict denominator\n])\ndef test_divide_non_numeric_types_raise_type_error_negative_case(a, b):\n    \"\"\"Test that non-numeric inputs raise TypeError with expected message\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(a, b)\n    assert str(excinfo.value) == \"Both arguments must be numeric\", (\n        f\"Expected TypeError message 'Both arguments must be numeric' for inputs {a!r}, {b!r}; \"\n        f\"got {str(excinfo.value)!r}\"\n    )\n\ndef test_divide_boolean_edge_case():\n    \"\"\"\n    Test boolean inputs are treated as numeric (bool is subclass of int in Python).\n    This test documents the current behavior: True -> 1, False -> 0.\n    \"\"\"\n    # Category: edge_case\n    # True should behave like 1\n    result_true = divide_numbers(True, 2)\n    assert result_true == 0.5, f\"Expected True / 2 to equal 0.5 (True treated as 1), got {result_true!r}\"\n\n    # False as numerator should produce 0.0 (0 / 2)\n    result_false = divide_numbers(False, 3)\n    assert float(result_false) == 0.0, f\"Expected False / 3 to equal 0.0 (False treated as 0), got {result_false!r}\"\n\ndef test_divide_nan_and_infinity_edge_case():\n    \"\"\"Test handling of NaN and infinity inputs (special float values)\"\"\"\n    # Category: edge_case\n    nan_value = float(\"nan\")\n    inf_value = float(\"inf\")\n\n    # NaN propagated through division: result should be NaN\n    result_nan = divide_numbers(nan_value, 1.0)\n    assert math.isnan(result_nan), f\"Expected division of NaN to produce NaN, got {result_nan!r}\"\n\n    # Division by infinity should yield 0.0 (or -0.0 depending on sign); check closeness to 0\n    result_div_inf = divide_numbers(1.0, inf_value)\n    assert math.isclose(result_div_inf, 0.0, rel_tol=0.0, abs_tol=1e-300), (\n        f\"Expected 1.0 / inf to be 0.0 (or nearly 0), got {result_div_inf!r}\"\n    )\n\ndef test_divide_extremely_large_values_edge_case():\n    \"\"\"Test behavior with extremely large values possibly producing infinity\"\"\"\n    # Category: edge_case\n    large = 1e308\n    small = 1e-308\n\n    # large / small may overflow to infinity in IEEE-754 double precision\n    result = divide_numbers(large, small)\n    # Accept either a very large finite number or inf depending on platform; assert not raising and type is float\n    assert isinstance(result, float), f\"Expected result to be a float for large division, got type {type(result)}\"\n    # If overflowed, it should be infinity\n    if math.isinf(result):\n        assert result > 0, f\"Expected positive infinity for {large}/{small}, got {result!r}\"\n    else:\n        # If not overflowed, check it is a very large number\n        assert result > 1e300, f\"Expected a very large number for {large}/{small}, got {result!r}\"",
      "test_methods": [
        {
          "name": "test_divide_integers_positive_case",
          "code": "def test_divide_integers_positive_case():\n    \"\"\"Test integer division returns correct quotient\"\"\"\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5, f\"Expected 10 / 2 to equal 5, got {result!r}\""
        },
        {
          "name": "test_divide_floats_positive_case",
          "code": "def test_divide_floats_positive_case():\n    \"\"\"Test float division returns correct floating-point result\"\"\"\n    # Category: positive\n    result = divide_numbers(7.5, 2.5)\n    assert math.isclose(result, 3.0, rel_tol=1e-12), f\"Expected 7.5 / 2.5 to be close to 3.0, got {result!r}\""
        },
        {
          "name": "test_divide_negative_numbers_positive_case",
          "code": "def test_divide_negative_numbers_positive_case():\n    \"\"\"Test dividing negative numbers (sign handling)\"\"\"\n    # Category: positive\n    result = divide_numbers(-9, -3)\n    assert result == 3, f\"Expected -9 / -3 to equal 3, got {result!r}\""
        },
        {
          "name": "test_divide_zero_numerator_boundary_case",
          "code": "def test_divide_zero_numerator_boundary_case():\n    \"\"\"Test zero numerator returns zero (boundary case)\"\"\"\n    # Category: boundary\n    result = divide_numbers(0, 5)\n    # Division of 0 by non-zero should be 0.0 (float) or 0 (int). Normalize to float for comparison.\n    assert float(result) == 0.0, f\"Expected 0 / 5 to equal 0.0, got {result!r}\""
        },
        {
          "name": "test_divide_by_zero_raises_value_error_negative_case",
          "code": "def test_divide_by_zero_raises_value_error_negative_case():\n    \"\"\"Test dividing by zero raises ValueError with expected message\"\"\"\n    # Category: negative\n    with pytest.raises(ValueError) as excinfo:\n        divide_numbers(1, 0)\n    assert str(excinfo.value) == \"Cannot divide by zero\", (\n        f\"Expected ValueError message 'Cannot divide by zero', got {str(excinfo.value)!r}\"\n    )\n\n@pytest.mark.parametrize(\"a,b\", [\n    (\"10\", 2),     # string numerator\n    (10, \"2\"),     # string denominator\n    (None, 1),     # None numerator\n    (1, None),     # None denominator\n    ([1,2], 2),    # list numerator\n    (1, {\"x\":1}),  # dict denominator\n])"
        },
        {
          "name": "test_divide_non_numeric_types_raise_type_error_negative_case",
          "code": "def test_divide_non_numeric_types_raise_type_error_negative_case():\n    \"\"\"Test that non-numeric inputs raise TypeError with expected message\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(a, b)\n    assert str(excinfo.value) == \"Both arguments must be numeric\", (\n        f\"Expected TypeError message 'Both arguments must be numeric' for inputs {a!r}, {b!r}; \"\n        f\"got {str(excinfo.value)!r}\"\n    )"
        },
        {
          "name": "test_divide_boolean_edge_case",
          "code": "def test_divide_boolean_edge_case():\n    \"\"\"\n    Test boolean inputs are treated as numeric (bool is subclass of int in Python).\n    This test documents the current behavior: True -> 1, False -> 0.\n    \"\"\"\n    # Category: edge_case\n    # True should behave like 1\n    result_true = divide_numbers(True, 2)\n    assert result_true == 0.5, f\"Expected True / 2 to equal 0.5 (True treated as 1), got {result_true!r}\"\n\n    # False as numerator should produce 0.0 (0 / 2)\n    result_false = divide_numbers(False, 3)\n    assert float(result_false) == 0.0, f\"Expected False / 3 to equal 0.0 (False treated as 0), got {result_false!r}\""
        },
        {
          "name": "test_divide_nan_and_infinity_edge_case",
          "code": "def test_divide_nan_and_infinity_edge_case():\n    \"\"\"Test handling of NaN and infinity inputs (special float values)\"\"\"\n    # Category: edge_case\n    nan_value = float(\"nan\")\n    inf_value = float(\"inf\")\n\n    # NaN propagated through division: result should be NaN\n    result_nan = divide_numbers(nan_value, 1.0)\n    assert math.isnan(result_nan), f\"Expected division of NaN to produce NaN, got {result_nan!r}\"\n\n    # Division by infinity should yield 0.0 (or -0.0 depending on sign); check closeness to 0\n    result_div_inf = divide_numbers(1.0, inf_value)\n    assert math.isclose(result_div_inf, 0.0, rel_tol=0.0, abs_tol=1e-300), (\n        f\"Expected 1.0 / inf to be 0.0 (or nearly 0), got {result_div_inf!r}\"\n    )"
        },
        {
          "name": "test_divide_extremely_large_values_edge_case",
          "code": "def test_divide_extremely_large_values_edge_case():\n    \"\"\"Test behavior with extremely large values possibly producing infinity\"\"\"\n    # Category: edge_case\n    large = 1e308\n    small = 1e-308\n\n    # large / small may overflow to infinity in IEEE-754 double precision\n    result = divide_numbers(large, small)\n    # Accept either a very large finite number or inf depending on platform; assert not raising and type is float\n    assert isinstance(result, float), f\"Expected result to be a float for large division, got type {type(result)}\"\n    # If overflowed, it should be infinity\n    if math.isinf(result):\n        assert result > 0, f\"Expected positive infinity for {large}/{small}, got {result!r}\"\n    else:\n        # If not overflowed, check it is a very large number\n        assert result > 1e300, f\"Expected a very large number for {large}/{small}, got {result!r}\""
        }
      ],
      "test_count": 9
    },
    "grok-3-mini": {
      "raw_response": "```python\nimport pytest\n\n# Import the function to test\nfrom your_module import divide_numbers  # Replace 'your_module' with the actual module name\n\ndef test_divide_numbers_positive_integers():\n    '''Test normal division with positive integers'''\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should correctly divide 10 by 2 and return 5.0\"\n\ndef test_divide_numbers_positive_floats():\n    '''Test normal division with floating-point numbers'''\n    # Category: positive\n    result = divide_numbers(3.5, 1.5)\n    assert result == (3.5 / 1.5), f\"Should correctly divide 3.5 by 1.5 and return approximately {3.5 / 1.5}\"\n\ndef test_divide_numbers_zero_numerator():\n    '''Test division where numerator is zero'''\n    # Category: edge_case\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should correctly divide 0 by 5 and return 0.0\"\n\ndef test_divide_numbers_boundary_division_by_one():\n    '''Test division by exactly one'''\n    # Category: boundary\n    result = divide_numbers(7, 1)\n    assert result == 7.0, \"Should correctly divide 7 by 1 and return 7.0\"\n\ndef test_divide_numbers_large_numbers():\n    '''Test division with very large numbers'''\n    # Category: edge_case  # Also touches on security by checking for potential overflow or precision issues in floats\n    result = divide_numbers(1e20, 2e10)\n    assert result == (1e20 / 2e10), f\"Should correctly divide 1e20 by 2e10 and return approximately {1e20 / 2e10}\"\n\ndef test_divide_numbers_denominator_zero():\n    '''Test error handling when denominator is zero'''\n    # Category: negative\n    with pytest.raises(ValueError, match=\"Cannot divide by zero\"):\n        divide_numbers(10, 0)\n    # Additional assertion to ensure no result is returned\n    assert True  # This line ensures the test passes if the exception is raised as expected\n\ndef test_divide_numbers_non_numeric_numerator():\n    '''Test error handling with non-numeric numerator'''\n    # Category: negative\n    with pytest.raises(TypeError, match=\"Both arguments must be numeric\"):\n        divide_numbers(\"ten\", 2)\n\ndef test_divide_numbers_non_numeric_denominator():\n    '''Test error handling with non-numeric denominator'''\n    # Category: negative\n    with pytest.raises(TypeError, match=\"Both arguments must be numeric\"):\n        divide_numbers(10, \"two\")\n\ndef test_divide_numbers_mixed_types():\n    '''Test error handling with mixed numeric and non-numeric inputs'''\n    # Category: negative  # Covers invalid inputs that might bypass simple checks\n    with pytest.raises(TypeError, match=\"Both arguments must be numeric\"):\n        divide_numbers(10, \"zero\")\n```\n\n### Explanation of the Generated Tests:\n- **Total Tests:** 9 (This provides comprehensive coverage without exceeding the 5-10 limit, focusing on quality.)\n- **Coverage Breakdown:**\n  - **Positive Cases (2 tests):** These verify normal functionality with valid numeric inputs, including integers and floats.\n  - **Edge Cases (2 tests):** These cover scenarios like dividing zero or using very large numbers, which are at the boundaries of typical usage.\n  - **Boundary Cases (1 test):** This specifically tests division by 1, which is a clear boundary value.\n  - **Negative Cases (4 tests):** These test invalid inputs and error conditions, ensuring that TypeError and ValueError are raised appropriately.\n  - **Security Considerations:** Incorporated into the edge case for large numbers (e.g., potential floating-point precision issues), as Python's float handling is generally robust but could be tested for edge behaviors. No dedicated security test was added since the function doesn't involve external inputs or vulnerabilities like code injection.\n\nThese tests use descriptive names, docstrings for clarity, and meaningful assertions. Error handling is tested with `pytest.raises` to verify both the exception type and its message, ensuring thorough validation.",
      "test_methods": [
        {
          "name": "test_divide_numbers_positive_integers",
          "code": "def test_divide_numbers_positive_integers():\n    '''Test normal division with positive integers'''\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should correctly divide 10 by 2 and return 5.0\""
        },
        {
          "name": "test_divide_numbers_positive_floats",
          "code": "def test_divide_numbers_positive_floats():\n    '''Test normal division with floating-point numbers'''\n    # Category: positive\n    result = divide_numbers(3.5, 1.5)\n    assert result == (3.5 / 1.5), f\"Should correctly divide 3.5 by 1.5 and return approximately {3.5 / 1.5}\""
        },
        {
          "name": "test_divide_numbers_zero_numerator",
          "code": "def test_divide_numbers_zero_numerator():\n    '''Test division where numerator is zero'''\n    # Category: edge_case\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should correctly divide 0 by 5 and return 0.0\""
        },
        {
          "name": "test_divide_numbers_boundary_division_by_one",
          "code": "def test_divide_numbers_boundary_division_by_one():\n    '''Test division by exactly one'''\n    # Category: boundary\n    result = divide_numbers(7, 1)\n    assert result == 7.0, \"Should correctly divide 7 by 1 and return 7.0\""
        },
        {
          "name": "test_divide_numbers_large_numbers",
          "code": "def test_divide_numbers_large_numbers():\n    '''Test division with very large numbers'''\n    # Category: edge_case  # Also touches on security by checking for potential overflow or precision issues in floats\n    result = divide_numbers(1e20, 2e10)\n    assert result == (1e20 / 2e10), f\"Should correctly divide 1e20 by 2e10 and return approximately {1e20 / 2e10}\""
        },
        {
          "name": "test_divide_numbers_denominator_zero",
          "code": "def test_divide_numbers_denominator_zero():\n    '''Test error handling when denominator is zero'''\n    # Category: negative\n    with pytest.raises(ValueError, match=\"Cannot divide by zero\"):\n        divide_numbers(10, 0)\n    # Additional assertion to ensure no result is returned\n    assert True  # This line ensures the test passes if the exception is raised as expected"
        },
        {
          "name": "test_divide_numbers_non_numeric_numerator",
          "code": "def test_divide_numbers_non_numeric_numerator():\n    '''Test error handling with non-numeric numerator'''\n    # Category: negative\n    with pytest.raises(TypeError, match=\"Both arguments must be numeric\"):\n        divide_numbers(\"ten\", 2)"
        },
        {
          "name": "test_divide_numbers_non_numeric_denominator",
          "code": "def test_divide_numbers_non_numeric_denominator():\n    '''Test error handling with non-numeric denominator'''\n    # Category: negative\n    with pytest.raises(TypeError, match=\"Both arguments must be numeric\"):\n        divide_numbers(10, \"two\")"
        },
        {
          "name": "test_divide_numbers_mixed_types",
          "code": "def test_divide_numbers_mixed_types():\n    '''Test error handling with mixed numeric and non-numeric inputs'''\n    # Category: negative  # Covers invalid inputs that might bypass simple checks\n    with pytest.raises(TypeError, match=\"Both arguments must be numeric\"):\n        divide_numbers(10, \"zero\")\n```\n\n### Explanation of the Generated Tests:\n- **Total Tests:** 9 (This provides comprehensive coverage without exceeding the 5-10 limit, focusing on quality.)\n- **Coverage Breakdown:**\n  - **Positive Cases (2 tests):** These verify normal functionality with valid numeric inputs, including integers and floats.\n  - **Edge Cases (2 tests):** These cover scenarios like dividing zero or using very large numbers, which are at the boundaries of typical usage.\n  - **Boundary Cases (1 test):** This specifically tests division by 1, which is a clear boundary value.\n  - **Negative Cases (4 tests):** These test invalid inputs and error conditions, ensuring that TypeError and ValueError are raised appropriately.\n  - **Security Considerations:** Incorporated into the edge case for large numbers (e.g., potential floating-point precision issues), as Python's float handling is generally robust but could be tested for edge behaviors. No dedicated security test was added since the function doesn't involve external inputs or vulnerabilities like code injection.\n\nThese tests use descriptive names, docstrings for clarity, and meaningful assertions. Error handling is tested with `pytest.raises` to verify both the exception type and its message, ensuring thorough validation."
        }
      ],
      "test_count": 9
    }
  },
  "all_classified_tests": [
    {
      "name": "test_divide_numbers_positive_normal",
      "code": "def test_divide_numbers_positive_normal():\n    \"\"\"Test normal division with positive integers.\"\"\"\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should return correct quotient for positive integers\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_positive_float",
      "code": "def test_divide_numbers_positive_float():\n    \"\"\"Test normal division with positive floats.\"\"\"\n    # Category: positive\n    result = divide_numbers(7.5, 2.5)\n    assert result == 3.0, \"Should return correct quotient for positive floats\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_negative_numerator",
      "code": "def test_divide_numbers_negative_numerator():\n    \"\"\"Test division with a negative numerator.\"\"\"\n    # Category: positive\n    result = divide_numbers(-10, 2)\n    assert result == -5.0, \"Should handle negative numerator correctly\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_negative_denominator",
      "code": "def test_divide_numbers_negative_denominator():\n    \"\"\"Test division with a negative denominator.\"\"\"\n    # Category: positive\n    result = divide_numbers(10, -2)\n    assert result == -5.0, \"Should handle negative denominator correctly\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_negative_both",
      "code": "def test_divide_numbers_negative_both():\n    \"\"\"Test division with both negative numerator and denominator.\"\"\"\n    # Category: positive\n    result = divide_numbers(-10, -2)\n    assert result == 5.0, \"Should handle both negative numbers correctly\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_zero_numerator",
      "code": "def test_divide_numbers_zero_numerator():\n    \"\"\"Test division with a zero numerator.\"\"\"\n    # Category: boundary\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should return 0 when numerator is 0\"",
      "category": "boundary",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_divide_by_zero",
      "code": "def test_divide_numbers_divide_by_zero():\n    \"\"\"Test division by zero, expecting a ValueError.\"\"\"\n    # Category: negative\n    with pytest.raises(ValueError) as excinfo:\n        divide_numbers(10, 0)\n    assert \"Cannot divide by zero\" in str(excinfo.value), \"Should raise ValueError for division by zero\"",
      "category": "negative",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_invalid_input_type_string",
      "code": "def test_divide_numbers_invalid_input_type_string():\n    \"\"\"Test with string input, expecting a TypeError.\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(\"10\", 2)\n    assert \"Both arguments must be numeric\" in str(excinfo.value), \"Should raise TypeError for string input\"",
      "category": "negative",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_invalid_input_type_list",
      "code": "def test_divide_numbers_invalid_input_type_list():\n    \"\"\"Test with list input, expecting a TypeError.\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(10, [1,2,3])\n    assert \"Both arguments must be numeric\" in str(excinfo.value), \"Should raise TypeError for list input\"",
      "category": "negative",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_large_numbers",
      "code": "def test_divide_numbers_large_numbers():\n    \"\"\"Test division with large numbers\"\"\"\n    # Category: edge_case\n    result = divide_numbers(1e10, 2)\n    assert result == 5e9, \"Should handle large numbers correctly\"\n```",
      "category": "edge_case",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_integers_positive_case",
      "code": "def test_divide_integers_positive_case():\n    \"\"\"Test integer division returns correct quotient\"\"\"\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5, f\"Expected 10 / 2 to equal 5, got {result!r}\"",
      "category": "positive",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_floats_positive_case",
      "code": "def test_divide_floats_positive_case():\n    \"\"\"Test float division returns correct floating-point result\"\"\"\n    # Category: positive\n    result = divide_numbers(7.5, 2.5)\n    assert math.isclose(result, 3.0, rel_tol=1e-12), f\"Expected 7.5 / 2.5 to be close to 3.0, got {result!r}\"",
      "category": "positive",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_negative_numbers_positive_case",
      "code": "def test_divide_negative_numbers_positive_case():\n    \"\"\"Test dividing negative numbers (sign handling)\"\"\"\n    # Category: positive\n    result = divide_numbers(-9, -3)\n    assert result == 3, f\"Expected -9 / -3 to equal 3, got {result!r}\"",
      "category": "positive",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_zero_numerator_boundary_case",
      "code": "def test_divide_zero_numerator_boundary_case():\n    \"\"\"Test zero numerator returns zero (boundary case)\"\"\"\n    # Category: boundary\n    result = divide_numbers(0, 5)\n    # Division of 0 by non-zero should be 0.0 (float) or 0 (int). Normalize to float for comparison.\n    assert float(result) == 0.0, f\"Expected 0 / 5 to equal 0.0, got {result!r}\"",
      "category": "boundary",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_by_zero_raises_value_error_negative_case",
      "code": "def test_divide_by_zero_raises_value_error_negative_case():\n    \"\"\"Test dividing by zero raises ValueError with expected message\"\"\"\n    # Category: negative\n    with pytest.raises(ValueError) as excinfo:\n        divide_numbers(1, 0)\n    assert str(excinfo.value) == \"Cannot divide by zero\", (\n        f\"Expected ValueError message 'Cannot divide by zero', got {str(excinfo.value)!r}\"\n    )\n\n@pytest.mark.parametrize(\"a,b\", [\n    (\"10\", 2),     # string numerator\n    (10, \"2\"),     # string denominator\n    (None, 1),     # None numerator\n    (1, None),     # None denominator\n    ([1,2], 2),    # list numerator\n    (1, {\"x\":1}),  # dict denominator\n])",
      "category": "negative",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_non_numeric_types_raise_type_error_negative_case",
      "code": "def test_divide_non_numeric_types_raise_type_error_negative_case():\n    \"\"\"Test that non-numeric inputs raise TypeError with expected message\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(a, b)\n    assert str(excinfo.value) == \"Both arguments must be numeric\", (\n        f\"Expected TypeError message 'Both arguments must be numeric' for inputs {a!r}, {b!r}; \"\n        f\"got {str(excinfo.value)!r}\"\n    )",
      "category": "negative",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_boolean_edge_case",
      "code": "def test_divide_boolean_edge_case():\n    \"\"\"\n    Test boolean inputs are treated as numeric (bool is subclass of int in Python).\n    This test documents the current behavior: True -> 1, False -> 0.\n    \"\"\"\n    # Category: edge_case\n    # True should behave like 1\n    result_true = divide_numbers(True, 2)\n    assert result_true == 0.5, f\"Expected True / 2 to equal 0.5 (True treated as 1), got {result_true!r}\"\n\n    # False as numerator should produce 0.0 (0 / 2)\n    result_false = divide_numbers(False, 3)\n    assert float(result_false) == 0.0, f\"Expected False / 3 to equal 0.0 (False treated as 0), got {result_false!r}\"",
      "category": "edge_case",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_nan_and_infinity_edge_case",
      "code": "def test_divide_nan_and_infinity_edge_case():\n    \"\"\"Test handling of NaN and infinity inputs (special float values)\"\"\"\n    # Category: edge_case\n    nan_value = float(\"nan\")\n    inf_value = float(\"inf\")\n\n    # NaN propagated through division: result should be NaN\n    result_nan = divide_numbers(nan_value, 1.0)\n    assert math.isnan(result_nan), f\"Expected division of NaN to produce NaN, got {result_nan!r}\"\n\n    # Division by infinity should yield 0.0 (or -0.0 depending on sign); check closeness to 0\n    result_div_inf = divide_numbers(1.0, inf_value)\n    assert math.isclose(result_div_inf, 0.0, rel_tol=0.0, abs_tol=1e-300), (\n        f\"Expected 1.0 / inf to be 0.0 (or nearly 0), got {result_div_inf!r}\"\n    )",
      "category": "edge_case",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_extremely_large_values_edge_case",
      "code": "def test_divide_extremely_large_values_edge_case():\n    \"\"\"Test behavior with extremely large values possibly producing infinity\"\"\"\n    # Category: edge_case\n    large = 1e308\n    small = 1e-308\n\n    # large / small may overflow to infinity in IEEE-754 double precision\n    result = divide_numbers(large, small)\n    # Accept either a very large finite number or inf depending on platform; assert not raising and type is float\n    assert isinstance(result, float), f\"Expected result to be a float for large division, got type {type(result)}\"\n    # If overflowed, it should be infinity\n    if math.isinf(result):\n        assert result > 0, f\"Expected positive infinity for {large}/{small}, got {result!r}\"\n    else:\n        # If not overflowed, check it is a very large number\n        assert result > 1e300, f\"Expected a very large number for {large}/{small}, got {result!r}\"",
      "category": "edge_case",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_numbers_positive_integers",
      "code": "def test_divide_numbers_positive_integers():\n    '''Test normal division with positive integers'''\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should correctly divide 10 by 2 and return 5.0\"",
      "category": "positive",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_positive_floats",
      "code": "def test_divide_numbers_positive_floats():\n    '''Test normal division with floating-point numbers'''\n    # Category: positive\n    result = divide_numbers(3.5, 1.5)\n    assert result == (3.5 / 1.5), f\"Should correctly divide 3.5 by 1.5 and return approximately {3.5 / 1.5}\"",
      "category": "positive",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_zero_numerator",
      "code": "def test_divide_numbers_zero_numerator():\n    '''Test division where numerator is zero'''\n    # Category: edge_case\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should correctly divide 0 by 5 and return 0.0\"",
      "category": "edge_case",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_boundary_division_by_one",
      "code": "def test_divide_numbers_boundary_division_by_one():\n    '''Test division by exactly one'''\n    # Category: boundary\n    result = divide_numbers(7, 1)\n    assert result == 7.0, \"Should correctly divide 7 by 1 and return 7.0\"",
      "category": "boundary",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_large_numbers",
      "code": "def test_divide_numbers_large_numbers():\n    '''Test division with very large numbers'''\n    # Category: edge_case  # Also touches on security by checking for potential overflow or precision issues in floats\n    result = divide_numbers(1e20, 2e10)\n    assert result == (1e20 / 2e10), f\"Should correctly divide 1e20 by 2e10 and return approximately {1e20 / 2e10}\"",
      "category": "edge_case",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_denominator_zero",
      "code": "def test_divide_numbers_denominator_zero():\n    '''Test error handling when denominator is zero'''\n    # Category: negative\n    with pytest.raises(ValueError, match=\"Cannot divide by zero\"):\n        divide_numbers(10, 0)\n    # Additional assertion to ensure no result is returned\n    assert True  # This line ensures the test passes if the exception is raised as expected",
      "category": "negative",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_non_numeric_numerator",
      "code": "def test_divide_numbers_non_numeric_numerator():\n    '''Test error handling with non-numeric numerator'''\n    # Category: negative\n    with pytest.raises(TypeError, match=\"Both arguments must be numeric\"):\n        divide_numbers(\"ten\", 2)",
      "category": "negative",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_non_numeric_denominator",
      "code": "def test_divide_numbers_non_numeric_denominator():\n    '''Test error handling with non-numeric denominator'''\n    # Category: negative\n    with pytest.raises(TypeError, match=\"Both arguments must be numeric\"):\n        divide_numbers(10, \"two\")",
      "category": "negative",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_mixed_types",
      "code": "def test_divide_numbers_mixed_types():\n    '''Test error handling with mixed numeric and non-numeric inputs'''\n    # Category: negative  # Covers invalid inputs that might bypass simple checks\n    with pytest.raises(TypeError, match=\"Both arguments must be numeric\"):\n        divide_numbers(10, \"zero\")\n```\n\n### Explanation of the Generated Tests:\n- **Total Tests:** 9 (This provides comprehensive coverage without exceeding the 5-10 limit, focusing on quality.)\n- **Coverage Breakdown:**\n  - **Positive Cases (2 tests):** These verify normal functionality with valid numeric inputs, including integers and floats.\n  - **Edge Cases (2 tests):** These cover scenarios like dividing zero or using very large numbers, which are at the boundaries of typical usage.\n  - **Boundary Cases (1 test):** This specifically tests division by 1, which is a clear boundary value.\n  - **Negative Cases (4 tests):** These test invalid inputs and error conditions, ensuring that TypeError and ValueError are raised appropriately.\n  - **Security Considerations:** Incorporated into the edge case for large numbers (e.g., potential floating-point precision issues), as Python's float handling is generally robust but could be tested for edge behaviors. No dedicated security test was added since the function doesn't involve external inputs or vulnerabilities like code injection.\n\nThese tests use descriptive names, docstrings for clarity, and meaningful assertions. Error handling is tested with `pytest.raises` to verify both the exception type and its message, ensuring thorough validation.",
      "category": "negative",
      "source_model": "grok-3-mini"
    }
  ],
  "synthesis_results": {
    "final_tests": [
      {
        "name": "test_divide_positive_integers",
        "code": "def test_divide_positive_integers():\n    \"\"\"Test division with positive integers.\"\"\"\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should return correct quotient for positive integers\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      },
      {
        "name": "test_divide_positive_floats",
        "code": "def test_divide_positive_floats():\n    \"\"\"Test division with positive floats.\"\"\"\n    result = divide_numbers(7.5, 2.5)\n    assert math.isclose(result, 3.0), \"Should return correct quotient for positive floats\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      },
      {
        "name": "test_divide_negative_numbers",
        "code": "def test_divide_negative_numbers():\n    \"\"\"Test division with negative numbers.\"\"\"\n    result = divide_numbers(-10, -2)\n    assert result == 5.0, \"Should handle both negative numbers correctly\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      },
      {
        "name": "test_divide_negative_numerator",
        "code": "def test_divide_negative_numerator():\n    \"\"\"Test division with a negative numerator.\"\"\"\n    result = divide_numbers(-10, 2)\n    assert result == -5.0, \"Should handle negative numerator correctly\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      },
      {
        "name": "test_divide_negative_denominator",
        "code": "def test_divide_negative_denominator():\n    \"\"\"Test division with a negative denominator.\"\"\"\n    result = divide_numbers(10, -2)\n    assert result == -5.0, \"Should handle negative denominator correctly\"\n\n\n# Boundary test cases",
        "category": "boundary",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      },
      {
        "name": "test_divide_zero_numerator",
        "code": "def test_divide_zero_numerator():\n    \"\"\"Test division with a zero numerator.\"\"\"\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should return 0 when numerator is 0\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      },
      {
        "name": "test_divide_by_one",
        "code": "def test_divide_by_one():\n    \"\"\"Test division by exactly one.\"\"\"\n    result = divide_numbers(7, 1)\n    assert result == 7.0, \"Should correctly divide 7 by 1 and return 7.0\"\n\n\n# Negative test cases (error handling)",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      },
      {
        "name": "test_divide_by_zero_raises_value_error",
        "code": "def test_divide_by_zero_raises_value_error():\n    \"\"\"Test division by zero, expecting a ValueError.\"\"\"\n    with pytest.raises(ValueError) as excinfo:\n        divide_numbers(10, 0)\n    assert \"Cannot divide by zero\" in str(excinfo.value), \"Should raise ValueError for division by zero\"\n\n\n@pytest.mark.parametrize(\"a,b\", [\n    (\"10\", 2),     # string numerator\n    (10, \"2\"),     # string denominator\n    (None, 1),     # None numerator\n    (1, None),     # None denominator\n    ([1,2], 2),    # list numerator\n    (1, {\"x\":1}),  # dict denominator\n])",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      },
      {
        "name": "test_divide_non_numeric_types_raise_type_error",
        "code": "def test_divide_non_numeric_types_raise_type_error():\n    \"\"\"Test that non-numeric inputs raise TypeError with expected message.\"\"\"\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(a, b)\n    assert \"Both arguments must be numeric\" in str(excinfo.value), (\n        f\"Expected TypeError message 'Both arguments must be numeric' for inputs {a!r}, {b!r}; \"\n        f\"got {str(excinfo.value)!r}\"\n    )\n\n\n# Edge cases",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      },
      {
        "name": "test_divide_large_numbers",
        "code": "def test_divide_large_numbers():\n    \"\"\"Test division with large numbers.\"\"\"\n    result = divide_numbers(1e10, 2)\n    assert result == 5e9, \"Should handle large numbers correctly\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      },
      {
        "name": "test_divide_booleans",
        "code": "def test_divide_booleans():\n    \"\"\"Test boolean inputs are treated as numeric (True -> 1, False -> 0).\"\"\"\n    # True should behave like 1\n    result_true = divide_numbers(True, 2)\n    assert result_true == 0.5, \"Expected True / 2 to equal 0.5 (True treated as 1)\"\n\n    # False as numerator should produce 0.0 (0 / 2)\n    result_false = divide_numbers(False, 3)\n    assert result_false == 0.0, \"Expected False / 3 to equal 0.0 (False treated as 0)\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      },
      {
        "name": "test_divide_nan_and_infinity",
        "code": "def test_divide_nan_and_infinity():\n    \"\"\"Test handling of NaN and infinity inputs.\"\"\"\n    nan_value = float(\"nan\")\n    inf_value = float(\"inf\")\n\n    # NaN propagated through division: result should be NaN\n    result_nan = divide_numbers(nan_value, 1.0)\n    assert math.isnan(result_nan), \"Expected division of NaN to produce NaN\"\n\n    # Division by infinity should yield 0.0 (or -0.0 depending on sign)\n    result_div_inf = divide_numbers(1.0, inf_value)\n    assert math.isclose(result_div_inf, 0.0, rel_tol=0.0, abs_tol=1e-300), \"Expected 1.0 / inf to be 0.0 (or nearly 0)\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      },
      {
        "name": "test_divide_extremely_large_values",
        "code": "def test_divide_extremely_large_values():\n    \"\"\"Test behavior with extremely large values possibly producing infinity.\"\"\"\n    large = 1e308\n    small = 1e-308\n\n    # large / small may overflow to infinity in IEEE-754 double precision\n    result = divide_numbers(large, small)\n    assert isinstance(result, float), \"Expected result to be a float for large division\"\n    if math.isinf(result):\n        assert result > 0, f\"Expected positive infinity for {large}/{small}, got {result!r}\"\n    else:\n        assert result > 1e300, f\"Expected a very large number for {large}/{small}, got {result!r}\"\n```",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "gemini-2.0-flash",
          "gpt-5-mini",
          "grok-3-mini"
        ]
      }
    ],
    "original_count": 28,
    "final_count": 13,
    "reduction_ratio": 0.5357142857142857,
    "synthesizer_model": "gemini-2.0-flash"
  },
  "final_test_file": "```python\n\"\"\"\nTest suite for the divide_numbers function.\n\nThis file contains pytest tests to verify the functionality of the\ndivide_numbers function, including positive and negative cases,\nboundary conditions, and error handling.\n\"\"\"\n\nimport pytest\nimport math\nfrom your_module import divide_numbers  # Replace your_module\n\n# Positive test cases\ndef test_divide_positive_integers():\n    \"\"\"Test division with positive integers.\"\"\"\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should return correct quotient for positive integers\"\n\n\ndef test_divide_positive_floats():\n    \"\"\"Test division with positive floats.\"\"\"\n    result = divide_numbers(7.5, 2.5)\n    assert math.isclose(result, 3.0), \"Should return correct quotient for positive floats\"\n\n\ndef test_divide_negative_numbers():\n    \"\"\"Test division with negative numbers.\"\"\"\n    result = divide_numbers(-10, -2)\n    assert result == 5.0, \"Should handle both negative numbers correctly\"\n\n\ndef test_divide_negative_numerator():\n    \"\"\"Test division with a negative numerator.\"\"\"\n    result = divide_numbers(-10, 2)\n    assert result == -5.0, \"Should handle negative numerator correctly\"\n\n\ndef test_divide_negative_denominator():\n    \"\"\"Test division with a negative denominator.\"\"\"\n    result = divide_numbers(10, -2)\n    assert result == -5.0, \"Should handle negative denominator correctly\"\n\n\n# Boundary test cases\ndef test_divide_zero_numerator():\n    \"\"\"Test division with a zero numerator.\"\"\"\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should return 0 when numerator is 0\"\n\n\ndef test_divide_by_one():\n    \"\"\"Test division by exactly one.\"\"\"\n    result = divide_numbers(7, 1)\n    assert result == 7.0, \"Should correctly divide 7 by 1 and return 7.0\"\n\n\n# Negative test cases (error handling)\ndef test_divide_by_zero_raises_value_error():\n    \"\"\"Test division by zero, expecting a ValueError.\"\"\"\n    with pytest.raises(ValueError) as excinfo:\n        divide_numbers(10, 0)\n    assert \"Cannot divide by zero\" in str(excinfo.value), \"Should raise ValueError for division by zero\"\n\n\n@pytest.mark.parametrize(\"a,b\", [\n    (\"10\", 2),     # string numerator\n    (10, \"2\"),     # string denominator\n    (None, 1),     # None numerator\n    (1, None),     # None denominator\n    ([1,2], 2),    # list numerator\n    (1, {\"x\":1}),  # dict denominator\n])\ndef test_divide_non_numeric_types_raise_type_error(a, b):\n    \"\"\"Test that non-numeric inputs raise TypeError with expected message.\"\"\"\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(a, b)\n    assert \"Both arguments must be numeric\" in str(excinfo.value), (\n        f\"Expected TypeError message 'Both arguments must be numeric' for inputs {a!r}, {b!r}; \"\n        f\"got {str(excinfo.value)!r}\"\n    )\n\n\n# Edge cases\ndef test_divide_large_numbers():\n    \"\"\"Test division with large numbers.\"\"\"\n    result = divide_numbers(1e10, 2)\n    assert result == 5e9, \"Should handle large numbers correctly\"\n\n\ndef test_divide_booleans():\n    \"\"\"Test boolean inputs are treated as numeric (True -> 1, False -> 0).\"\"\"\n    # True should behave like 1\n    result_true = divide_numbers(True, 2)\n    assert result_true == 0.5, \"Expected True / 2 to equal 0.5 (True treated as 1)\"\n\n    # False as numerator should produce 0.0 (0 / 2)\n    result_false = divide_numbers(False, 3)\n    assert result_false == 0.0, \"Expected False / 3 to equal 0.0 (False treated as 0)\"\n\n\ndef test_divide_nan_and_infinity():\n    \"\"\"Test handling of NaN and infinity inputs.\"\"\"\n    nan_value = float(\"nan\")\n    inf_value = float(\"inf\")\n\n    # NaN propagated through division: result should be NaN\n    result_nan = divide_numbers(nan_value, 1.0)\n    assert math.isnan(result_nan), \"Expected division of NaN to produce NaN\"\n\n    # Division by infinity should yield 0.0 (or -0.0 depending on sign)\n    result_div_inf = divide_numbers(1.0, inf_value)\n    assert math.isclose(result_div_inf, 0.0, rel_tol=0.0, abs_tol=1e-300), \"Expected 1.0 / inf to be 0.0 (or nearly 0)\"\n\n\ndef test_divide_extremely_large_values():\n    \"\"\"Test behavior with extremely large values possibly producing infinity.\"\"\"\n    large = 1e308\n    small = 1e-308\n\n    # large / small may overflow to infinity in IEEE-754 double precision\n    result = divide_numbers(large, small)\n    assert isinstance(result, float), \"Expected result to be a float for large division\"\n    if math.isinf(result):\n        assert result > 0, f\"Expected positive infinity for {large}/{small}, got {result!r}\"\n    else:\n        assert result > 1e300, f\"Expected a very large number for {large}/{small}, got {result!r}\"\n```",
  "coverage_results": {
    "success": false,
    "stdout": "\u001b[1m============================= test session starts ==============================\u001b[0m\nplatform darwin -- Python 3.9.0, pytest-8.4.2, pluggy-1.6.0 -- /Users/sepehr/IdeaProjects/testgen-council/venv/bin/python\ncachedir: .pytest_cache\nrootdir: /var/folders/b8/8kbfnxhx3l34cnrh1tkx_y8h0000gn/T\nplugins: anyio-4.10.0, cov-7.0.0\n\u001b[1mcollecting ... \u001b[0mcollected 0 items / 1 error\n\n==================================== ERRORS ====================================\n\u001b[31m\u001b[1m_______________________ ERROR collecting tmp6ntt86lc.py ________________________\u001b[0m\n\u001b[31m\u001b[1m\u001b[31mvenv/lib/python3.9/site-packages/_pytest/python.py\u001b[0m:498: in importtestmodule\n    \u001b[0mmod = import_path(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mvenv/lib/python3.9/site-packages/_pytest/pathlib.py\u001b[0m:587: in import_path\n    \u001b[0mimportlib.import_module(module_name)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py\u001b[0m:127: in import_module\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m _bootstrap._gcd_import(name[level:], package, level)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m<frozen importlib._bootstrap>\u001b[0m:1030: in _gcd_import\n    \u001b[0m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m<frozen importlib._bootstrap>\u001b[0m:1007: in _find_and_load\n    \u001b[0m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m<frozen importlib._bootstrap>\u001b[0m:986: in _find_and_load_unlocked\n    \u001b[0m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m<frozen importlib._bootstrap>\u001b[0m:680: in _load_unlocked\n    \u001b[0m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mvenv/lib/python3.9/site-packages/_pytest/assertion/rewrite.py\u001b[0m:177: in exec_module\n    \u001b[0msource_stat, co = _rewrite_test(fn, \u001b[96mself\u001b[39;49;00m.config)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mvenv/lib/python3.9/site-packages/_pytest/assertion/rewrite.py\u001b[0m:357: in _rewrite_test\n    \u001b[0mtree = ast.parse(source, filename=strfn)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/ast.py\u001b[0m:50: in parse\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcompile\u001b[39;49;00m(source, filename, mode, flags,\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE     File \"/var/folders/b8/8kbfnxhx3l34cnrh1tkx_y8h0000gn/T/tmp6ntt86lc.py\", line 5\u001b[0m\n\u001b[1m\u001b[31mE       ```python\u001b[0m\n\u001b[1m\u001b[31mE       ^\u001b[0m\n\u001b[1m\u001b[31mE   SyntaxError: invalid syntax\u001b[0m\u001b[0m\n\u001b[36m\u001b[1m=========================== short test summary info ============================\u001b[0m\n\u001b[31mERROR\u001b[0m ../../../../var/folders/b8/8kbfnxhx3l34cnrh1tkx_y8h0000gn/T/tmp6ntt86lc.py\n!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!\n\u001b[31m=============================== \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.33s\u001b[0m\u001b[31m ===============================\u001b[0m\n",
    "stderr": "",
    "coverage_percentage": 85.0
  },
  "statistics": {
    "original_test_count": 28,
    "final_test_count": 13,
    "reduction_ratio": 0.5357142857142857,
    "coverage_percentage": 85.0,
    "models_used": [
      "gemini-2.0-flash",
      "gpt-5-mini",
      "grok-3-mini"
    ],
    "categories_found": [
      "positive",
      "boundary",
      "negative",
      "edge_case"
    ],
    "synthesizer_model": "gemini-2.0-flash"
  }
}