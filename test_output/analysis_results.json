{
  "function_info": {
    "functions": [
      {
        "name": "divide_numbers",
        "args": [
          "a",
          "b"
        ],
        "docstring": "Divide two numbers with error handling\n\nArgs:\n    a (float): Numerator\n    b (float): Denominator\n\nReturns:\n    float: Result of division\n\nRaises:\n    ValueError: If denominator is zero\n    TypeError: If inputs are not numeric",
        "source_code": "def divide_numbers(a, b):\n    \"\"\"\n    Divide two numbers with error handling\n\n    Args:\n        a (float): Numerator\n        b (float): Denominator\n\n    Returns:\n        float: Result of division\n\n    Raises:\n        ValueError: If denominator is zero\n        TypeError: If inputs are not numeric\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numeric\")\n\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n\n    return a / b",
        "line_start": 1,
        "line_end": 22
      }
    ],
    "total_functions": 1,
    "source_code": "def divide_numbers(a, b):\n    \"\"\"\n    Divide two numbers with error handling\n\n    Args:\n        a (float): Numerator\n        b (float): Denominator\n\n    Returns:\n        float: Result of division\n\n    Raises:\n        ValueError: If denominator is zero\n        TypeError: If inputs are not numeric\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numeric\")\n\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n\n    return a / b"
  },
  "council_results": {
    "gemini-2.0-flash": {
      "raw_response": "```python\nimport pytest\n\ndef divide_numbers(a, b):\n    \"\"\"\n    Divide two numbers with error handling\n\n    Args:\n        a (float): Numerator\n        b (float): Denominator\n\n    Returns:\n        float: Result of division\n\n    Raises:\n        ValueError: If denominator is zero\n        TypeError: If inputs are not numeric\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numeric\")\n\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n\n    return a / b\n\n\ndef test_divide_numbers_positive_integers():\n    \"\"\"Test normal division with positive integers\"\"\"\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should correctly divide positive integers\"\n\ndef test_divide_numbers_positive_floats():\n    \"\"\"Test normal division with positive floats\"\"\"\n    # Category: positive\n    result = divide_numbers(7.5, 2.5)\n    assert result == 3.0, \"Should correctly divide positive floats\"\n\ndef test_divide_numbers_negative_numerator():\n    \"\"\"Test division with a negative numerator\"\"\"\n    # Category: positive\n    result = divide_numbers(-10, 2)\n    assert result == -5.0, \"Should correctly divide with negative numerator\"\n\ndef test_divide_numbers_negative_denominator():\n    \"\"\"Test division with a negative denominator\"\"\"\n    # Category: positive\n    result = divide_numbers(10, -2)\n    assert result == -5.0, \"Should correctly divide with negative denominator\"\n\ndef test_divide_numbers_negative_both():\n    \"\"\"Test division with both arguments negative\"\"\"\n    # Category: positive\n    result = divide_numbers(-10, -2)\n    assert result == 5.0, \"Should correctly divide with both negative numbers\"\n\ndef test_divide_numbers_zero_numerator():\n    \"\"\"Test division with zero numerator\"\"\"\n    # Category: boundary\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should correctly divide zero by a number\"\n\ndef test_divide_numbers_denominator_close_to_zero():\n    \"\"\"Test division with a denominator very close to zero\"\"\"\n    # Category: edge_case\n    result = divide_numbers(10, 0.000001)\n    assert result == pytest.approx(10000000.0), \"Should correctly divide with a denominator close to zero\"\n\ndef test_divide_numbers_type_error():\n    \"\"\"Test when non-numeric arguments are passed\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(\"10\", 2)\n    assert \"Both arguments must be numeric\" in str(excinfo.value)\n\ndef test_divide_numbers_zero_division_error():\n    \"\"\"Test when the denominator is zero\"\"\"\n    # Category: negative\n    with pytest.raises(ValueError) as excinfo:\n        divide_numbers(10, 0)\n    assert \"Cannot divide by zero\" in str(excinfo.value)\n\ndef test_divide_numbers_large_numbers():\n    \"\"\"Test division with very large numbers\"\"\"\n    # Category: edge_case\n    result = divide_numbers(1e10, 1e5)\n    assert result == 1e5, \"Should correctly divide large numbers\"\n```",
      "test_methods": [
        {
          "name": "test_divide_numbers_positive_integers",
          "code": "def test_divide_numbers_positive_integers():\n    \"\"\"Test normal division with positive integers\"\"\"\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should correctly divide positive integers\""
        },
        {
          "name": "test_divide_numbers_positive_floats",
          "code": "def test_divide_numbers_positive_floats():\n    \"\"\"Test normal division with positive floats\"\"\"\n    # Category: positive\n    result = divide_numbers(7.5, 2.5)\n    assert result == 3.0, \"Should correctly divide positive floats\""
        },
        {
          "name": "test_divide_numbers_negative_numerator",
          "code": "def test_divide_numbers_negative_numerator():\n    \"\"\"Test division with a negative numerator\"\"\"\n    # Category: positive\n    result = divide_numbers(-10, 2)\n    assert result == -5.0, \"Should correctly divide with negative numerator\""
        },
        {
          "name": "test_divide_numbers_negative_denominator",
          "code": "def test_divide_numbers_negative_denominator():\n    \"\"\"Test division with a negative denominator\"\"\"\n    # Category: positive\n    result = divide_numbers(10, -2)\n    assert result == -5.0, \"Should correctly divide with negative denominator\""
        },
        {
          "name": "test_divide_numbers_negative_both",
          "code": "def test_divide_numbers_negative_both():\n    \"\"\"Test division with both arguments negative\"\"\"\n    # Category: positive\n    result = divide_numbers(-10, -2)\n    assert result == 5.0, \"Should correctly divide with both negative numbers\""
        },
        {
          "name": "test_divide_numbers_zero_numerator",
          "code": "def test_divide_numbers_zero_numerator():\n    \"\"\"Test division with zero numerator\"\"\"\n    # Category: boundary\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should correctly divide zero by a number\""
        },
        {
          "name": "test_divide_numbers_denominator_close_to_zero",
          "code": "def test_divide_numbers_denominator_close_to_zero():\n    \"\"\"Test division with a denominator very close to zero\"\"\"\n    # Category: edge_case\n    result = divide_numbers(10, 0.000001)\n    assert result == pytest.approx(10000000.0), \"Should correctly divide with a denominator close to zero\""
        },
        {
          "name": "test_divide_numbers_type_error",
          "code": "def test_divide_numbers_type_error():\n    \"\"\"Test when non-numeric arguments are passed\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(\"10\", 2)\n    assert \"Both arguments must be numeric\" in str(excinfo.value)"
        },
        {
          "name": "test_divide_numbers_zero_division_error",
          "code": "def test_divide_numbers_zero_division_error():\n    \"\"\"Test when the denominator is zero\"\"\"\n    # Category: negative\n    with pytest.raises(ValueError) as excinfo:\n        divide_numbers(10, 0)\n    assert \"Cannot divide by zero\" in str(excinfo.value)"
        },
        {
          "name": "test_divide_numbers_large_numbers",
          "code": "def test_divide_numbers_large_numbers():\n    \"\"\"Test division with very large numbers\"\"\"\n    # Category: edge_case\n    result = divide_numbers(1e10, 1e5)\n    assert result == 1e5, \"Should correctly divide large numbers\"\n```"
        }
      ],
      "test_count": 10
    },
    "gpt-5-mini": {
      "raw_response": "import math\nfrom decimal import Decimal\nimport pytest\n\nfrom divide_module import divide_numbers  # adjust import as needed if function is in a different module\n\n\ndef test_divide_integers_positive_case():\n    '''Test normal functionality with integer inputs'''\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5, \"Expected 10 divided by 2 to equal 5\"\n\n\ndef test_divide_floats_positive_case():\n    '''Test normal functionality with float inputs'''\n    # Category: positive\n    result = divide_numbers(7.5, 2.5)\n    assert result == 3.0, \"Expected 7.5 divided by 2.5 to equal 3.0\"\n\n\ndef test_divide_zero_denominator_raises_value_error():\n    '''Division by zero (integer zero) should raise ValueError with proper message'''\n    # Category: negative\n    with pytest.raises(ValueError) as exc:\n        divide_numbers(5, 0)\n    assert str(exc.value) == \"Cannot divide by zero\", \"Expected ValueError message for zero denominator\"\n\n\ndef test_divide_zero_denominator_float_raises_value_error():\n    '''Division by zero (float zero and negative zero) should raise ValueError'''\n    # Category: boundary\n    # Test with 0.0\n    with pytest.raises(ValueError) as exc1:\n        divide_numbers(5.0, 0.0)\n    assert str(exc1.value) == \"Cannot divide by zero\", \"Expected ValueError message for 0.0 denominator\"\n\n    # Test with -0.0 (should be treated as zero)\n    with pytest.raises(ValueError) as exc2:\n        divide_numbers(5.0, -0.0)\n    assert str(exc2.value) == \"Cannot divide by zero\", \"Expected ValueError message for -0.0 denominator\"\n\n\ndef test_non_numeric_types_raise_type_error():\n    '''Passing non-numeric types (e.g., string) should raise TypeError'''\n    # Category: negative\n    with pytest.raises(TypeError) as exc:\n        divide_numbers(\"10\", 2)\n    assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError when numerator is a string\"\n\n    with pytest.raises(TypeError) as exc2:\n        divide_numbers(10, \"2\")\n    assert str(exc2.value) == \"Both arguments must be numeric\", \"Expected TypeError when denominator is a string\"\n\n\ndef test_decimal_instances_not_accepted_type_error():\n    '''Decimal instances should not be automatically accepted (function only allows int/float)'''\n    # Category: edge_case\n    with pytest.raises(TypeError) as exc:\n        divide_numbers(Decimal(\"3.0\"), 1)\n    assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError when using Decimal for numerator\"\n\n    with pytest.raises(TypeError) as exc2:\n        divide_numbers(1, Decimal(\"3.0\"))\n    assert str(exc2.value) == \"Both arguments must be numeric\", \"Expected TypeError when using Decimal for denominator\"\n\n\ndef test_bool_is_subclass_of_int_edge_case():\n    '''Booleans are subclasses of int in Python; verify behavior is consistent (True -> 1, False -> 0)'''\n    # Category: edge_case\n    # True treated as 1\n    result_true = divide_numbers(True, 2)\n    assert result_true == 0.5, \"Expected True to be treated as 1, so True/2 == 0.5\"\n\n    # False treated as 0 -> dividing 0 by non-zero should return 0.0\n    result_false = divide_numbers(False, 3)\n    assert result_false == 0.0, \"Expected False to be treated as 0, so False/3 == 0.0\"\n\n    # Dividing a number by False (zero) should raise ValueError\n    with pytest.raises(ValueError) as exc:\n        divide_numbers(1, False)\n    assert str(exc.value) == \"Cannot divide by zero\", \"Expected ValueError when denominator is False (zero)\"\n\n\ndef test_special_float_values_nan_and_inf_boundary_security():\n    '''Verify behavior with NaN and Infinity inputs'''\n    # Category: security\n    # NaN in denominator should propagate NaN result (float behavior)\n    result_nan = divide_numbers(1.0, float(\"nan\"))\n    assert math.isnan(result_nan), \"Expected result to be NaN when denominator is NaN\"\n\n    # Infinity numerator should result in infinity (preserving sign)\n    result_inf = divide_numbers(float(\"inf\"), 2.0)\n    assert math.isinf(result_inf) and result_inf > 0, \"Expected positive infinity when numerator is +inf\"\n\n    # Negative infinity numerator\n    result_neg_inf = divide_numbers(float(\"-inf\"), 2.0)\n    assert math.isinf(result_neg_inf) and result_neg_inf < 0, \"Expected negative infinity when numerator is -inf\"\n\n\ndef test_object_with_float_method_not_autocoerced_security():\n    '''Ensure objects implementing __float__ are not silently accepted; explicit int/float required'''\n    # Category: security\n    class CustomNumber:\n        def __float__(self):\n            return 3.0\n\n    with pytest.raises(TypeError) as exc:\n        divide_numbers(CustomNumber(), 1)\n    assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError for objects that are not int/float even if they implement __float__\"",
      "test_methods": [
        {
          "name": "test_divide_integers_positive_case",
          "code": "def test_divide_integers_positive_case():\n    '''Test normal functionality with integer inputs'''\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5, \"Expected 10 divided by 2 to equal 5\""
        },
        {
          "name": "test_divide_floats_positive_case",
          "code": "def test_divide_floats_positive_case():\n    '''Test normal functionality with float inputs'''\n    # Category: positive\n    result = divide_numbers(7.5, 2.5)\n    assert result == 3.0, \"Expected 7.5 divided by 2.5 to equal 3.0\""
        },
        {
          "name": "test_divide_zero_denominator_raises_value_error",
          "code": "def test_divide_zero_denominator_raises_value_error():\n    '''Division by zero (integer zero) should raise ValueError with proper message'''\n    # Category: negative\n    with pytest.raises(ValueError) as exc:\n        divide_numbers(5, 0)\n    assert str(exc.value) == \"Cannot divide by zero\", \"Expected ValueError message for zero denominator\""
        },
        {
          "name": "test_divide_zero_denominator_float_raises_value_error",
          "code": "def test_divide_zero_denominator_float_raises_value_error():\n    '''Division by zero (float zero and negative zero) should raise ValueError'''\n    # Category: boundary\n    # Test with 0.0\n    with pytest.raises(ValueError) as exc1:\n        divide_numbers(5.0, 0.0)\n    assert str(exc1.value) == \"Cannot divide by zero\", \"Expected ValueError message for 0.0 denominator\"\n\n    # Test with -0.0 (should be treated as zero)\n    with pytest.raises(ValueError) as exc2:\n        divide_numbers(5.0, -0.0)\n    assert str(exc2.value) == \"Cannot divide by zero\", \"Expected ValueError message for -0.0 denominator\""
        },
        {
          "name": "test_non_numeric_types_raise_type_error",
          "code": "def test_non_numeric_types_raise_type_error():\n    '''Passing non-numeric types (e.g., string) should raise TypeError'''\n    # Category: negative\n    with pytest.raises(TypeError) as exc:\n        divide_numbers(\"10\", 2)\n    assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError when numerator is a string\"\n\n    with pytest.raises(TypeError) as exc2:\n        divide_numbers(10, \"2\")\n    assert str(exc2.value) == \"Both arguments must be numeric\", \"Expected TypeError when denominator is a string\""
        },
        {
          "name": "test_decimal_instances_not_accepted_type_error",
          "code": "def test_decimal_instances_not_accepted_type_error():\n    '''Decimal instances should not be automatically accepted (function only allows int/float)'''\n    # Category: edge_case\n    with pytest.raises(TypeError) as exc:\n        divide_numbers(Decimal(\"3.0\"), 1)\n    assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError when using Decimal for numerator\"\n\n    with pytest.raises(TypeError) as exc2:\n        divide_numbers(1, Decimal(\"3.0\"))\n    assert str(exc2.value) == \"Both arguments must be numeric\", \"Expected TypeError when using Decimal for denominator\""
        },
        {
          "name": "test_bool_is_subclass_of_int_edge_case",
          "code": "def test_bool_is_subclass_of_int_edge_case():\n    '''Booleans are subclasses of int in Python; verify behavior is consistent (True -> 1, False -> 0)'''\n    # Category: edge_case\n    # True treated as 1\n    result_true = divide_numbers(True, 2)\n    assert result_true == 0.5, \"Expected True to be treated as 1, so True/2 == 0.5\"\n\n    # False treated as 0 -> dividing 0 by non-zero should return 0.0\n    result_false = divide_numbers(False, 3)\n    assert result_false == 0.0, \"Expected False to be treated as 0, so False/3 == 0.0\"\n\n    # Dividing a number by False (zero) should raise ValueError\n    with pytest.raises(ValueError) as exc:\n        divide_numbers(1, False)\n    assert str(exc.value) == \"Cannot divide by zero\", \"Expected ValueError when denominator is False (zero)\""
        },
        {
          "name": "test_special_float_values_nan_and_inf_boundary_security",
          "code": "def test_special_float_values_nan_and_inf_boundary_security():\n    '''Verify behavior with NaN and Infinity inputs'''\n    # Category: security\n    # NaN in denominator should propagate NaN result (float behavior)\n    result_nan = divide_numbers(1.0, float(\"nan\"))\n    assert math.isnan(result_nan), \"Expected result to be NaN when denominator is NaN\"\n\n    # Infinity numerator should result in infinity (preserving sign)\n    result_inf = divide_numbers(float(\"inf\"), 2.0)\n    assert math.isinf(result_inf) and result_inf > 0, \"Expected positive infinity when numerator is +inf\"\n\n    # Negative infinity numerator\n    result_neg_inf = divide_numbers(float(\"-inf\"), 2.0)\n    assert math.isinf(result_neg_inf) and result_neg_inf < 0, \"Expected negative infinity when numerator is -inf\""
        },
        {
          "name": "test_object_with_float_method_not_autocoerced_security",
          "code": "def test_object_with_float_method_not_autocoerced_security():\n    '''Ensure objects implementing __float__ are not silently accepted; explicit int/float required'''\n    # Category: security\n    class CustomNumber:\n        def __float__(self):\n            return 3.0\n\n    with pytest.raises(TypeError) as exc:\n        divide_numbers(CustomNumber(), 1)\n    assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError for objects that are not int/float even if they implement __float__\""
        }
      ],
      "test_count": 9
    },
    "grok-3-mini": {
      "raw_response": "```python\nimport pytest\n\n# Tests for the divide_numbers function\n\ndef test_divide_numbers_positive_integers():\n    \"\"\"\n    Test normal functionality with positive integer inputs\n    \"\"\"\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should correctly divide positive integers\"\n\ndef test_divide_numbers_positive_with_negatives():\n    \"\"\"\n    Test normal functionality with a mix of positive and negative inputs\n    \"\"\"\n    # Category: positive\n    result = divide_numbers(-10, 2)\n    assert result == -5.0, \"Should correctly divide a negative numerator by a positive denominator\"\n\ndef test_divide_numbers_boundary_small_denominator():\n    \"\"\"\n    Test boundary condition with a very small positive denominator\n    \"\"\"\n    # Category: boundary\n    result = divide_numbers(1, 1e-10)  # This should result in a very large number\n    assert result == 1e10, \"Should handle division by a very small number without issues\"\n\ndef test_divide_numbers_edge_case_zero_numerator():\n    \"\"\"\n    Test edge case where the numerator is zero\n    \"\"\"\n    # Category: edge_case\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should correctly return zero when numerator is zero\"\n\ndef test_divide_numbers_edge_case_denominator_one():\n    \"\"\"\n    Test edge case where the denominator is one\n    \"\"\"\n    # Category: edge_case\n    result = divide_numbers(7, 1)\n    assert result == 7.0, \"Should correctly return the numerator when denominator is one\"\n\ndef test_divide_numbers_negative_divide_by_zero():\n    \"\"\"\n    Test error handling for division by zero\n    \"\"\"\n    # Category: negative\n    with pytest.raises(ValueError, match=\"Cannot divide by zero\"):\n        divide_numbers(10, 0)\n    # No assertion needed beyond the raise, but we check the error message for completeness\n\ndef test_divide_numbers_negative_non_numeric_input():\n    \"\"\"\n    Test error handling for non-numeric inputs\n    \"\"\"\n    # Category: negative\n    with pytest.raises(TypeError, match=\"Both arguments must be numeric\"):\n        divide_numbers(\"a\", 2)\n    # This ensures the function raises the correct error for invalid types\n```\n\n### Explanation of Tests:\n- **Total Tests**: 7 (as per the requirement to generate 5-10, focusing on quality and coverage).\n- **Coverage**:\n  - **Positive Cases**: 2 tests (normal usage with integers and mixed signs) to verify the function works as expected for valid inputs.\n  - **Boundary Cases**: 1 test (division by a very small number) to check behavior near floating-point limits.\n  - **Edge Cases**: 2 tests (zero numerator and denominator of 1) to cover special scenarios that might not be typical but are valid.\n  - **Negative Cases**: 2 tests (division by zero and non-numeric input) to ensure proper error raising and messages.\n  - **Security Considerations**: Not explicitly tested here, as the function doesn't involve external inputs, networks, or vulnerabilities like injection. In a real-world scenario, if inputs were from untrusted sources, we'd consider overflow or precision issues, but Python's float handles these gracefully (e.g., very large numbers result in inf, which isn't a security risk in this context).\n- **Why These Tests?**: They provide comprehensive coverage without redundancy. Each test has descriptive names, docstrings, and assertions with meaningful messages. Error handling uses `pytest.raises` to verify exceptions and their messages, ensuring the function's robustness.",
      "test_methods": [
        {
          "name": "test_divide_numbers_positive_integers",
          "code": "def test_divide_numbers_positive_integers():\n    \"\"\"\n    Test normal functionality with positive integer inputs\n    \"\"\"\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should correctly divide positive integers\""
        },
        {
          "name": "test_divide_numbers_positive_with_negatives",
          "code": "def test_divide_numbers_positive_with_negatives():\n    \"\"\"\n    Test normal functionality with a mix of positive and negative inputs\n    \"\"\"\n    # Category: positive\n    result = divide_numbers(-10, 2)\n    assert result == -5.0, \"Should correctly divide a negative numerator by a positive denominator\""
        },
        {
          "name": "test_divide_numbers_boundary_small_denominator",
          "code": "def test_divide_numbers_boundary_small_denominator():\n    \"\"\"\n    Test boundary condition with a very small positive denominator\n    \"\"\"\n    # Category: boundary\n    result = divide_numbers(1, 1e-10)  # This should result in a very large number\n    assert result == 1e10, \"Should handle division by a very small number without issues\""
        },
        {
          "name": "test_divide_numbers_edge_case_zero_numerator",
          "code": "def test_divide_numbers_edge_case_zero_numerator():\n    \"\"\"\n    Test edge case where the numerator is zero\n    \"\"\"\n    # Category: edge_case\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should correctly return zero when numerator is zero\""
        },
        {
          "name": "test_divide_numbers_edge_case_denominator_one",
          "code": "def test_divide_numbers_edge_case_denominator_one():\n    \"\"\"\n    Test edge case where the denominator is one\n    \"\"\"\n    # Category: edge_case\n    result = divide_numbers(7, 1)\n    assert result == 7.0, \"Should correctly return the numerator when denominator is one\""
        },
        {
          "name": "test_divide_numbers_negative_divide_by_zero",
          "code": "def test_divide_numbers_negative_divide_by_zero():\n    \"\"\"\n    Test error handling for division by zero\n    \"\"\"\n    # Category: negative\n    with pytest.raises(ValueError, match=\"Cannot divide by zero\"):\n        divide_numbers(10, 0)\n    # No assertion needed beyond the raise, but we check the error message for completeness"
        },
        {
          "name": "test_divide_numbers_negative_non_numeric_input",
          "code": "def test_divide_numbers_negative_non_numeric_input():\n    \"\"\"\n    Test error handling for non-numeric inputs\n    \"\"\"\n    # Category: negative\n    with pytest.raises(TypeError, match=\"Both arguments must be numeric\"):\n        divide_numbers(\"a\", 2)\n    # This ensures the function raises the correct error for invalid types\n```\n\n### Explanation of Tests:\n- **Total Tests**: 7 (as per the requirement to generate 5-10, focusing on quality and coverage).\n- **Coverage**:\n  - **Positive Cases**: 2 tests (normal usage with integers and mixed signs) to verify the function works as expected for valid inputs.\n  - **Boundary Cases**: 1 test (division by a very small number) to check behavior near floating-point limits.\n  - **Edge Cases**: 2 tests (zero numerator and denominator of 1) to cover special scenarios that might not be typical but are valid.\n  - **Negative Cases**: 2 tests (division by zero and non-numeric input) to ensure proper error raising and messages.\n  - **Security Considerations**: Not explicitly tested here, as the function doesn't involve external inputs, networks, or vulnerabilities like injection. In a real-world scenario, if inputs were from untrusted sources, we'd consider overflow or precision issues, but Python's float handles these gracefully (e.g., very large numbers result in inf, which isn't a security risk in this context).\n- **Why These Tests?**: They provide comprehensive coverage without redundancy. Each test has descriptive names, docstrings, and assertions with meaningful messages. Error handling uses `pytest.raises` to verify exceptions and their messages, ensuring the function's robustness."
        }
      ],
      "test_count": 7
    }
  },
  "all_classified_tests": [
    {
      "name": "test_divide_numbers_positive_integers",
      "code": "def test_divide_numbers_positive_integers():\n    \"\"\"Test normal division with positive integers\"\"\"\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should correctly divide positive integers\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_positive_floats",
      "code": "def test_divide_numbers_positive_floats():\n    \"\"\"Test normal division with positive floats\"\"\"\n    # Category: positive\n    result = divide_numbers(7.5, 2.5)\n    assert result == 3.0, \"Should correctly divide positive floats\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_negative_numerator",
      "code": "def test_divide_numbers_negative_numerator():\n    \"\"\"Test division with a negative numerator\"\"\"\n    # Category: positive\n    result = divide_numbers(-10, 2)\n    assert result == -5.0, \"Should correctly divide with negative numerator\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_negative_denominator",
      "code": "def test_divide_numbers_negative_denominator():\n    \"\"\"Test division with a negative denominator\"\"\"\n    # Category: positive\n    result = divide_numbers(10, -2)\n    assert result == -5.0, \"Should correctly divide with negative denominator\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_negative_both",
      "code": "def test_divide_numbers_negative_both():\n    \"\"\"Test division with both arguments negative\"\"\"\n    # Category: positive\n    result = divide_numbers(-10, -2)\n    assert result == 5.0, \"Should correctly divide with both negative numbers\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_zero_numerator",
      "code": "def test_divide_numbers_zero_numerator():\n    \"\"\"Test division with zero numerator\"\"\"\n    # Category: boundary\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should correctly divide zero by a number\"",
      "category": "boundary",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_denominator_close_to_zero",
      "code": "def test_divide_numbers_denominator_close_to_zero():\n    \"\"\"Test division with a denominator very close to zero\"\"\"\n    # Category: edge_case\n    result = divide_numbers(10, 0.000001)\n    assert result == pytest.approx(10000000.0), \"Should correctly divide with a denominator close to zero\"",
      "category": "edge_case",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_type_error",
      "code": "def test_divide_numbers_type_error():\n    \"\"\"Test when non-numeric arguments are passed\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError) as excinfo:\n        divide_numbers(\"10\", 2)\n    assert \"Both arguments must be numeric\" in str(excinfo.value)",
      "category": "negative",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_zero_division_error",
      "code": "def test_divide_numbers_zero_division_error():\n    \"\"\"Test when the denominator is zero\"\"\"\n    # Category: negative\n    with pytest.raises(ValueError) as excinfo:\n        divide_numbers(10, 0)\n    assert \"Cannot divide by zero\" in str(excinfo.value)",
      "category": "negative",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_numbers_large_numbers",
      "code": "def test_divide_numbers_large_numbers():\n    \"\"\"Test division with very large numbers\"\"\"\n    # Category: edge_case\n    result = divide_numbers(1e10, 1e5)\n    assert result == 1e5, \"Should correctly divide large numbers\"\n```",
      "category": "edge_case",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_divide_integers_positive_case",
      "code": "def test_divide_integers_positive_case():\n    '''Test normal functionality with integer inputs'''\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5, \"Expected 10 divided by 2 to equal 5\"",
      "category": "positive",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_floats_positive_case",
      "code": "def test_divide_floats_positive_case():\n    '''Test normal functionality with float inputs'''\n    # Category: positive\n    result = divide_numbers(7.5, 2.5)\n    assert result == 3.0, \"Expected 7.5 divided by 2.5 to equal 3.0\"",
      "category": "positive",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_zero_denominator_raises_value_error",
      "code": "def test_divide_zero_denominator_raises_value_error():\n    '''Division by zero (integer zero) should raise ValueError with proper message'''\n    # Category: negative\n    with pytest.raises(ValueError) as exc:\n        divide_numbers(5, 0)\n    assert str(exc.value) == \"Cannot divide by zero\", \"Expected ValueError message for zero denominator\"",
      "category": "negative",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_zero_denominator_float_raises_value_error",
      "code": "def test_divide_zero_denominator_float_raises_value_error():\n    '''Division by zero (float zero and negative zero) should raise ValueError'''\n    # Category: boundary\n    # Test with 0.0\n    with pytest.raises(ValueError) as exc1:\n        divide_numbers(5.0, 0.0)\n    assert str(exc1.value) == \"Cannot divide by zero\", \"Expected ValueError message for 0.0 denominator\"\n\n    # Test with -0.0 (should be treated as zero)\n    with pytest.raises(ValueError) as exc2:\n        divide_numbers(5.0, -0.0)\n    assert str(exc2.value) == \"Cannot divide by zero\", \"Expected ValueError message for -0.0 denominator\"",
      "category": "boundary",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_non_numeric_types_raise_type_error",
      "code": "def test_non_numeric_types_raise_type_error():\n    '''Passing non-numeric types (e.g., string) should raise TypeError'''\n    # Category: negative\n    with pytest.raises(TypeError) as exc:\n        divide_numbers(\"10\", 2)\n    assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError when numerator is a string\"\n\n    with pytest.raises(TypeError) as exc2:\n        divide_numbers(10, \"2\")\n    assert str(exc2.value) == \"Both arguments must be numeric\", \"Expected TypeError when denominator is a string\"",
      "category": "negative",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_decimal_instances_not_accepted_type_error",
      "code": "def test_decimal_instances_not_accepted_type_error():\n    '''Decimal instances should not be automatically accepted (function only allows int/float)'''\n    # Category: edge_case\n    with pytest.raises(TypeError) as exc:\n        divide_numbers(Decimal(\"3.0\"), 1)\n    assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError when using Decimal for numerator\"\n\n    with pytest.raises(TypeError) as exc2:\n        divide_numbers(1, Decimal(\"3.0\"))\n    assert str(exc2.value) == \"Both arguments must be numeric\", \"Expected TypeError when using Decimal for denominator\"",
      "category": "edge_case",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_bool_is_subclass_of_int_edge_case",
      "code": "def test_bool_is_subclass_of_int_edge_case():\n    '''Booleans are subclasses of int in Python; verify behavior is consistent (True -> 1, False -> 0)'''\n    # Category: edge_case\n    # True treated as 1\n    result_true = divide_numbers(True, 2)\n    assert result_true == 0.5, \"Expected True to be treated as 1, so True/2 == 0.5\"\n\n    # False treated as 0 -> dividing 0 by non-zero should return 0.0\n    result_false = divide_numbers(False, 3)\n    assert result_false == 0.0, \"Expected False to be treated as 0, so False/3 == 0.0\"\n\n    # Dividing a number by False (zero) should raise ValueError\n    with pytest.raises(ValueError) as exc:\n        divide_numbers(1, False)\n    assert str(exc.value) == \"Cannot divide by zero\", \"Expected ValueError when denominator is False (zero)\"",
      "category": "edge_case",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_special_float_values_nan_and_inf_boundary_security",
      "code": "def test_special_float_values_nan_and_inf_boundary_security():\n    '''Verify behavior with NaN and Infinity inputs'''\n    # Category: security\n    # NaN in denominator should propagate NaN result (float behavior)\n    result_nan = divide_numbers(1.0, float(\"nan\"))\n    assert math.isnan(result_nan), \"Expected result to be NaN when denominator is NaN\"\n\n    # Infinity numerator should result in infinity (preserving sign)\n    result_inf = divide_numbers(float(\"inf\"), 2.0)\n    assert math.isinf(result_inf) and result_inf > 0, \"Expected positive infinity when numerator is +inf\"\n\n    # Negative infinity numerator\n    result_neg_inf = divide_numbers(float(\"-inf\"), 2.0)\n    assert math.isinf(result_neg_inf) and result_neg_inf < 0, \"Expected negative infinity when numerator is -inf\"",
      "category": "security",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_object_with_float_method_not_autocoerced_security",
      "code": "def test_object_with_float_method_not_autocoerced_security():\n    '''Ensure objects implementing __float__ are not silently accepted; explicit int/float required'''\n    # Category: security\n    class CustomNumber:\n        def __float__(self):\n            return 3.0\n\n    with pytest.raises(TypeError) as exc:\n        divide_numbers(CustomNumber(), 1)\n    assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError for objects that are not int/float even if they implement __float__\"",
      "category": "security",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_divide_numbers_positive_integers",
      "code": "def test_divide_numbers_positive_integers():\n    \"\"\"\n    Test normal functionality with positive integer inputs\n    \"\"\"\n    # Category: positive\n    result = divide_numbers(10, 2)\n    assert result == 5.0, \"Should correctly divide positive integers\"",
      "category": "positive",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_positive_with_negatives",
      "code": "def test_divide_numbers_positive_with_negatives():\n    \"\"\"\n    Test normal functionality with a mix of positive and negative inputs\n    \"\"\"\n    # Category: positive\n    result = divide_numbers(-10, 2)\n    assert result == -5.0, \"Should correctly divide a negative numerator by a positive denominator\"",
      "category": "positive",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_boundary_small_denominator",
      "code": "def test_divide_numbers_boundary_small_denominator():\n    \"\"\"\n    Test boundary condition with a very small positive denominator\n    \"\"\"\n    # Category: boundary\n    result = divide_numbers(1, 1e-10)  # This should result in a very large number\n    assert result == 1e10, \"Should handle division by a very small number without issues\"",
      "category": "boundary",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_edge_case_zero_numerator",
      "code": "def test_divide_numbers_edge_case_zero_numerator():\n    \"\"\"\n    Test edge case where the numerator is zero\n    \"\"\"\n    # Category: edge_case\n    result = divide_numbers(0, 5)\n    assert result == 0.0, \"Should correctly return zero when numerator is zero\"",
      "category": "edge_case",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_edge_case_denominator_one",
      "code": "def test_divide_numbers_edge_case_denominator_one():\n    \"\"\"\n    Test edge case where the denominator is one\n    \"\"\"\n    # Category: edge_case\n    result = divide_numbers(7, 1)\n    assert result == 7.0, \"Should correctly return the numerator when denominator is one\"",
      "category": "edge_case",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_negative_divide_by_zero",
      "code": "def test_divide_numbers_negative_divide_by_zero():\n    \"\"\"\n    Test error handling for division by zero\n    \"\"\"\n    # Category: negative\n    with pytest.raises(ValueError, match=\"Cannot divide by zero\"):\n        divide_numbers(10, 0)\n    # No assertion needed beyond the raise, but we check the error message for completeness",
      "category": "negative",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_divide_numbers_negative_non_numeric_input",
      "code": "def test_divide_numbers_negative_non_numeric_input():\n    \"\"\"\n    Test error handling for non-numeric inputs\n    \"\"\"\n    # Category: negative\n    with pytest.raises(TypeError, match=\"Both arguments must be numeric\"):\n        divide_numbers(\"a\", 2)\n    # This ensures the function raises the correct error for invalid types\n```\n\n### Explanation of Tests:\n- **Total Tests**: 7 (as per the requirement to generate 5-10, focusing on quality and coverage).\n- **Coverage**:\n  - **Positive Cases**: 2 tests (normal usage with integers and mixed signs) to verify the function works as expected for valid inputs.\n  - **Boundary Cases**: 1 test (division by a very small number) to check behavior near floating-point limits.\n  - **Edge Cases**: 2 tests (zero numerator and denominator of 1) to cover special scenarios that might not be typical but are valid.\n  - **Negative Cases**: 2 tests (division by zero and non-numeric input) to ensure proper error raising and messages.\n  - **Security Considerations**: Not explicitly tested here, as the function doesn't involve external inputs, networks, or vulnerabilities like injection. In a real-world scenario, if inputs were from untrusted sources, we'd consider overflow or precision issues, but Python's float handles these gracefully (e.g., very large numbers result in inf, which isn't a security risk in this context).\n- **Why These Tests?**: They provide comprehensive coverage without redundancy. Each test has descriptive names, docstrings, and assertions with meaningful messages. Error handling uses `pytest.raises` to verify exceptions and their messages, ensuring the function's robustness.",
      "category": "negative",
      "source_model": "grok-3-mini"
    }
  ],
  "synthesis_results": {
    "final_tests": [
      {
        "name": "test_divide_numbers_positive_integers",
        "code": "def test_divide_numbers_positive_integers():\n        \"\"\"Test normal division with positive integers\"\"\"\n        result = divide_numbers(10, 2)\n        assert result == 5.0, \"Should correctly divide positive integers\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_divide_numbers_positive_floats",
        "code": "def test_divide_numbers_positive_floats():\n        \"\"\"Test normal division with positive floats\"\"\"\n        result = divide_numbers(7.5, 2.5)\n        assert result == 3.0, \"Should correctly divide positive floats\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_divide_numbers_negative_numerator",
        "code": "def test_divide_numbers_negative_numerator():\n        \"\"\"Test division with a negative numerator\"\"\"\n        result = divide_numbers(-10, 2)\n        assert result == -5.0, \"Should correctly divide with negative numerator\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_divide_numbers_negative_denominator",
        "code": "def test_divide_numbers_negative_denominator():\n        \"\"\"Test division with a negative denominator\"\"\"\n        result = divide_numbers(10, -2)\n        assert result == -5.0, \"Should correctly divide with negative denominator\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_divide_numbers_negative_both",
        "code": "def test_divide_numbers_negative_both():\n        \"\"\"Test division with both arguments negative\"\"\"\n        result = divide_numbers(-10, -2)\n        assert result == 5.0, \"Should correctly divide with both negative numbers\"\n\n\n# Boundary test cases\nclass TestBoundaryCases:\n    \"\"\"\n    Test suite for boundary test cases\n    \"\"\"",
        "category": "boundary",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_divide_numbers_small_denominator",
        "code": "def test_divide_numbers_small_denominator():\n        \"\"\"Test division with a very small positive denominator\"\"\"\n        result = divide_numbers(1, 1e-10)\n        assert result == 1e10, \"Should handle division by a very small number\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_special_float_values_nan_and_inf",
        "code": "def test_special_float_values_nan_and_inf():\n        \"\"\"Verify behavior with NaN and Infinity inputs\"\"\"\n        result_nan = divide_numbers(1.0, float(\"nan\"))\n        assert math.isnan(result_nan), \"Expected result to be NaN when denominator is NaN\"\n\n        result_inf = divide_numbers(float(\"inf\"), 2.0)\n        assert math.isinf(result_inf) and result_inf > 0, \"Expected positive infinity when numerator is +inf\"\n\n        result_neg_inf = divide_numbers(float(\"-inf\"), 2.0)\n        assert math.isinf(result_neg_inf) and result_neg_inf < 0, \"Expected negative infinity when numerator is -inf\"\n\n\n# Edge case test cases\nclass TestEdgeCases:\n    \"\"\"\n    Test suite for edge cases\n    \"\"\"",
        "category": "boundary",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_divide_numbers_zero_numerator",
        "code": "def test_divide_numbers_zero_numerator():\n        \"\"\"Test division with zero numerator\"\"\"\n        result = divide_numbers(0, 5)\n        assert result == 0.0, \"Should correctly divide zero by a number\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_divide_numbers_denominator_one",
        "code": "def test_divide_numbers_denominator_one():\n        \"\"\"Test division with denominator equal to one\"\"\"\n        result = divide_numbers(7, 1)\n        assert result == 7.0, \"Should correctly return the numerator when denominator is one\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_bool_is_subclass_of_int",
        "code": "def test_bool_is_subclass_of_int():\n        \"\"\"Verify behavior when using boolean values (True and False)\"\"\"\n        result_true = divide_numbers(True, 2)\n        assert result_true == 0.5, \"Expected True to be treated as 1, so True/2 == 0.5\"\n\n        result_false = divide_numbers(False, 3)\n        assert result_false == 0.0, \"Expected False to be treated as 0, so False/3 == 0.0\"\n\n        with pytest.raises(ValueError) as exc:\n            divide_numbers(1, False)\n        assert str(exc.value) == \"Cannot divide by zero\", \"Expected ValueError when denominator is False (zero)\"\n\n\n# Negative test cases\nclass TestNegativeCases:\n    \"\"\"\n    Test suite for negative test cases (error handling)\n    \"\"\"",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_divide_numbers_zero_division_error",
        "code": "def test_divide_numbers_zero_division_error():\n        \"\"\"Test when the denominator is zero\"\"\"\n        with pytest.raises(ValueError) as excinfo:\n            divide_numbers(10, 0)\n        assert \"Cannot divide by zero\" in str(excinfo.value)",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_divide_numbers_type_error",
        "code": "def test_divide_numbers_type_error():\n        \"\"\"Test when non-numeric arguments are passed\"\"\"\n        with pytest.raises(TypeError) as excinfo:\n            divide_numbers(\"10\", 2)\n        assert \"Both arguments must be numeric\" in str(excinfo.value)",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_non_numeric_types_raise_type_error",
        "code": "def test_non_numeric_types_raise_type_error():\n        \"\"\"Passing non-numeric types should raise TypeError\"\"\"\n        with pytest.raises(TypeError) as exc:\n            divide_numbers(10, \"2\")\n        assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError when denominator is a string\"",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_decimal_instances_not_accepted_type_error",
        "code": "def test_decimal_instances_not_accepted_type_error():\n        '''Decimal instances should not be automatically accepted (function only allows int/float)'''\n        with pytest.raises(TypeError) as exc:\n            divide_numbers(Decimal(\"3.0\"), 1)\n        assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError when using Decimal for numerator\"",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_object_with_float_method_not_autocoerced",
        "code": "def test_object_with_float_method_not_autocoerced():\n        '''Ensure objects implementing __float__ are not silently accepted; explicit int/float required'''\n        class CustomNumber:\n            def __float__(self):\n                return 3.0\n\n        with pytest.raises(TypeError) as exc:\n            divide_numbers(CustomNumber(), 1)\n        assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError for objects that are not int/float even if they implement __float__\"\n```",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      }
    ],
    "original_count": 26,
    "final_count": 15,
    "reduction_ratio": 0.4230769230769231,
    "synthesizer_model": "gemini-2.0-flash"
  },
  "final_test_file": "```python\n\"\"\"\nTest suite for the divide_numbers function.\n\nThis suite covers positive and negative test cases,\nboundary conditions, edge cases, and error handling.\n\"\"\"\n\nimport pytest\nimport math\nfrom decimal import Decimal\n\ndef divide_numbers(a, b):\n    \"\"\"\n    Divide two numbers with error handling\n\n    Args:\n        a (float): Numerator\n        b (float): Denominator\n\n    Returns:\n        float: Result of division\n\n    Raises:\n        ValueError: If denominator is zero\n        TypeError: If inputs are not numeric\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numeric\")\n\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n\n    return a / b\n\n\n# Positive test cases\nclass TestPositiveCases:\n    \"\"\"\n    Test suite for positive test cases\n    \"\"\"\n    def test_divide_numbers_positive_integers(self):\n        \"\"\"Test normal division with positive integers\"\"\"\n        result = divide_numbers(10, 2)\n        assert result == 5.0, \"Should correctly divide positive integers\"\n\n    def test_divide_numbers_positive_floats(self):\n        \"\"\"Test normal division with positive floats\"\"\"\n        result = divide_numbers(7.5, 2.5)\n        assert result == 3.0, \"Should correctly divide positive floats\"\n\n    def test_divide_numbers_negative_numerator(self):\n        \"\"\"Test division with a negative numerator\"\"\"\n        result = divide_numbers(-10, 2)\n        assert result == -5.0, \"Should correctly divide with negative numerator\"\n\n    def test_divide_numbers_negative_denominator(self):\n        \"\"\"Test division with a negative denominator\"\"\"\n        result = divide_numbers(10, -2)\n        assert result == -5.0, \"Should correctly divide with negative denominator\"\n\n    def test_divide_numbers_negative_both(self):\n        \"\"\"Test division with both arguments negative\"\"\"\n        result = divide_numbers(-10, -2)\n        assert result == 5.0, \"Should correctly divide with both negative numbers\"\n\n\n# Boundary test cases\nclass TestBoundaryCases:\n    \"\"\"\n    Test suite for boundary test cases\n    \"\"\"\n    def test_divide_numbers_small_denominator(self):\n        \"\"\"Test division with a very small positive denominator\"\"\"\n        result = divide_numbers(1, 1e-10)\n        assert result == 1e10, \"Should handle division by a very small number\"\n\n    def test_special_float_values_nan_and_inf(self):\n        \"\"\"Verify behavior with NaN and Infinity inputs\"\"\"\n        result_nan = divide_numbers(1.0, float(\"nan\"))\n        assert math.isnan(result_nan), \"Expected result to be NaN when denominator is NaN\"\n\n        result_inf = divide_numbers(float(\"inf\"), 2.0)\n        assert math.isinf(result_inf) and result_inf > 0, \"Expected positive infinity when numerator is +inf\"\n\n        result_neg_inf = divide_numbers(float(\"-inf\"), 2.0)\n        assert math.isinf(result_neg_inf) and result_neg_inf < 0, \"Expected negative infinity when numerator is -inf\"\n\n\n# Edge case test cases\nclass TestEdgeCases:\n    \"\"\"\n    Test suite for edge cases\n    \"\"\"\n    def test_divide_numbers_zero_numerator(self):\n        \"\"\"Test division with zero numerator\"\"\"\n        result = divide_numbers(0, 5)\n        assert result == 0.0, \"Should correctly divide zero by a number\"\n\n    def test_divide_numbers_denominator_one(self):\n        \"\"\"Test division with denominator equal to one\"\"\"\n        result = divide_numbers(7, 1)\n        assert result == 7.0, \"Should correctly return the numerator when denominator is one\"\n\n    def test_bool_is_subclass_of_int(self):\n        \"\"\"Verify behavior when using boolean values (True and False)\"\"\"\n        result_true = divide_numbers(True, 2)\n        assert result_true == 0.5, \"Expected True to be treated as 1, so True/2 == 0.5\"\n\n        result_false = divide_numbers(False, 3)\n        assert result_false == 0.0, \"Expected False to be treated as 0, so False/3 == 0.0\"\n\n        with pytest.raises(ValueError) as exc:\n            divide_numbers(1, False)\n        assert str(exc.value) == \"Cannot divide by zero\", \"Expected ValueError when denominator is False (zero)\"\n\n\n# Negative test cases\nclass TestNegativeCases:\n    \"\"\"\n    Test suite for negative test cases (error handling)\n    \"\"\"\n    def test_divide_numbers_zero_division_error(self):\n        \"\"\"Test when the denominator is zero\"\"\"\n        with pytest.raises(ValueError) as excinfo:\n            divide_numbers(10, 0)\n        assert \"Cannot divide by zero\" in str(excinfo.value)\n\n    def test_divide_numbers_type_error(self):\n        \"\"\"Test when non-numeric arguments are passed\"\"\"\n        with pytest.raises(TypeError) as excinfo:\n            divide_numbers(\"10\", 2)\n        assert \"Both arguments must be numeric\" in str(excinfo.value)\n\n    def test_non_numeric_types_raise_type_error(self):\n        \"\"\"Passing non-numeric types should raise TypeError\"\"\"\n        with pytest.raises(TypeError) as exc:\n            divide_numbers(10, \"2\")\n        assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError when denominator is a string\"\n\n    def test_decimal_instances_not_accepted_type_error(self):\n        '''Decimal instances should not be automatically accepted (function only allows int/float)'''\n        with pytest.raises(TypeError) as exc:\n            divide_numbers(Decimal(\"3.0\"), 1)\n        assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError when using Decimal for numerator\"\n\n    def test_object_with_float_method_not_autocoerced(self):\n        '''Ensure objects implementing __float__ are not silently accepted; explicit int/float required'''\n        class CustomNumber:\n            def __float__(self):\n                return 3.0\n\n        with pytest.raises(TypeError) as exc:\n            divide_numbers(CustomNumber(), 1)\n        assert str(exc.value) == \"Both arguments must be numeric\", \"Expected TypeError for objects that are not int/float even if they implement __float__\"\n```",
  "coverage_results": {
    "success": false,
    "stdout": "\u001b[1m============================= test session starts ==============================\u001b[0m\nplatform darwin -- Python 3.9.0, pytest-8.4.2, pluggy-1.6.0 -- /Users/sepehr/IdeaProjects/testgen-council/venv/bin/python\ncachedir: .pytest_cache\nrootdir: /var/folders/b8/8kbfnxhx3l34cnrh1tkx_y8h0000gn/T\nplugins: anyio-4.10.0, cov-7.0.0\n\u001b[1mcollecting ... \u001b[0mcollected 0 items / 1 error\n\n==================================== ERRORS ====================================\n\u001b[31m\u001b[1m_______________________ ERROR collecting tmpdvn2pu7y.py ________________________\u001b[0m\n\u001b[31m\u001b[1m\u001b[31mvenv/lib/python3.9/site-packages/_pytest/python.py\u001b[0m:498: in importtestmodule\n    \u001b[0mmod = import_path(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mvenv/lib/python3.9/site-packages/_pytest/pathlib.py\u001b[0m:587: in import_path\n    \u001b[0mimportlib.import_module(module_name)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py\u001b[0m:127: in import_module\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m _bootstrap._gcd_import(name[level:], package, level)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m<frozen importlib._bootstrap>\u001b[0m:1030: in _gcd_import\n    \u001b[0m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m<frozen importlib._bootstrap>\u001b[0m:1007: in _find_and_load\n    \u001b[0m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m<frozen importlib._bootstrap>\u001b[0m:986: in _find_and_load_unlocked\n    \u001b[0m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m<frozen importlib._bootstrap>\u001b[0m:680: in _load_unlocked\n    \u001b[0m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mvenv/lib/python3.9/site-packages/_pytest/assertion/rewrite.py\u001b[0m:177: in exec_module\n    \u001b[0msource_stat, co = _rewrite_test(fn, \u001b[96mself\u001b[39;49;00m.config)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mvenv/lib/python3.9/site-packages/_pytest/assertion/rewrite.py\u001b[0m:357: in _rewrite_test\n    \u001b[0mtree = ast.parse(source, filename=strfn)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/ast.py\u001b[0m:50: in parse\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcompile\u001b[39;49;00m(source, filename, mode, flags,\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE     File \"/var/folders/b8/8kbfnxhx3l34cnrh1tkx_y8h0000gn/T/tmpdvn2pu7y.py\", line 5\u001b[0m\n\u001b[1m\u001b[31mE       ```python\u001b[0m\n\u001b[1m\u001b[31mE       ^\u001b[0m\n\u001b[1m\u001b[31mE   SyntaxError: invalid syntax\u001b[0m\u001b[0m\n\u001b[36m\u001b[1m=========================== short test summary info ============================\u001b[0m\n\u001b[31mERROR\u001b[0m ../../../../var/folders/b8/8kbfnxhx3l34cnrh1tkx_y8h0000gn/T/tmpdvn2pu7y.py\n!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!\n\u001b[31m=============================== \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.33s\u001b[0m\u001b[31m ===============================\u001b[0m\n",
    "stderr": "",
    "coverage_percentage": 85.0
  },
  "statistics": {
    "original_test_count": 26,
    "final_test_count": 15,
    "reduction_ratio": 0.4230769230769231,
    "coverage_percentage": 85.0,
    "models_used": [
      "gemini-2.0-flash",
      "gpt-5-mini",
      "grok-3-mini"
    ],
    "categories_found": [
      "positive",
      "boundary",
      "edge_case",
      "negative",
      "security"
    ],
    "synthesizer_model": "gemini-2.0-flash"
  }
}