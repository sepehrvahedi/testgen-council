{
  "function_info": {
    "functions": [
      {
        "name": "example_function",
        "args": [
          "x",
          "y"
        ],
        "docstring": "Add two numbers together\n\nArgs:\n    x (int): First number\n    y (int): Second number\n    \nReturns:\n    int: Sum of x and y",
        "source_code": "def example_function(x, y):\n    \"\"\"\n    Add two numbers together\n    \n    Args:\n        x (int): First number\n        y (int): Second number\n        \n    Returns:\n        int: Sum of x and y\n    \"\"\"\n    return x + y",
        "line_start": 1,
        "line_end": 12
      }
    ],
    "total_functions": 1,
    "source_code": "def example_function(x, y):\n    \"\"\"\n    Add two numbers together\n    \n    Args:\n        x (int): First number\n        y (int): Second number\n        \n    Returns:\n        int: Sum of x and y\n    \"\"\"\n    return x + y"
  },
  "council_results": {
    "gemini-2.0-flash": {
      "raw_response": "```python\nimport pytest\n\ndef example_function(x, y):\n    \"\"\"\n    Add two numbers together\n    \n    Args:\n        x (int): First number\n        y (int): Second number\n        \n    Returns:\n        int: Sum of x and y\n    \"\"\"\n    return x + y\n\ndef test_example_function_positive_normal():\n    '''Test normal addition with positive integers'''\n    # Category: positive\n    result = example_function(5, 3)\n    assert result == 8, \"Should return the correct sum of positive integers\"\n\ndef test_example_function_positive_zero():\n    '''Test addition with zero'''\n    # Category: edge_case\n    result = example_function(5, 0)\n    assert result == 5, \"Should return the first number when the second is zero\"\n\ndef test_example_function_negative_normal():\n    '''Test addition with negative integers'''\n    # Category: positive\n    result = example_function(-5, -3)\n    assert result == -8, \"Should return the correct sum of negative integers\"\n\ndef test_example_function_mixed_positive_negative():\n    '''Test addition with mixed positive and negative integers'''\n    # Category: positive\n    result = example_function(5, -3)\n    assert result == 2, \"Should return the correct sum of mixed positive and negative integers\"\n\ndef test_example_function_boundary_large_numbers():\n    '''Test addition with large numbers'''\n    # Category: boundary\n    result = example_function(10**9, 10**9)\n    assert result == 2 * 10**9, \"Should return the correct sum of large integers\"\n\ndef test_example_function_edge_case_max_int():\n    '''Test addition with the maximum integer value'''\n    # Category: edge_case\n    import sys\n    max_int = sys.maxsize\n    result = example_function(max_int, 1)\n    assert result == max_int + 1, \"Should return the correct sum when adding to max int (might overflow depending on system)\"\n\ndef test_example_function_negative_invalid_input_string():\n    '''Test addition with string inputs'''\n    # Category: negative\n    with pytest.raises(TypeError):\n        example_function(\"a\", 1)\n\ndef test_example_function_negative_invalid_input_float():\n    '''Test addition with float inputs'''\n    # Category: negative\n    result = example_function(2.5, 3.5)\n    assert result == 6.0, \"Should handle float inputs correctly\"\n```",
      "test_methods": [
        {
          "name": "test_example_function_positive_normal",
          "code": "def test_example_function_positive_normal():\n    '''Test normal addition with positive integers'''\n    # Category: positive\n    result = example_function(5, 3)\n    assert result == 8, \"Should return the correct sum of positive integers\""
        },
        {
          "name": "test_example_function_positive_zero",
          "code": "def test_example_function_positive_zero():\n    '''Test addition with zero'''\n    # Category: edge_case\n    result = example_function(5, 0)\n    assert result == 5, \"Should return the first number when the second is zero\""
        },
        {
          "name": "test_example_function_negative_normal",
          "code": "def test_example_function_negative_normal():\n    '''Test addition with negative integers'''\n    # Category: positive\n    result = example_function(-5, -3)\n    assert result == -8, \"Should return the correct sum of negative integers\""
        },
        {
          "name": "test_example_function_mixed_positive_negative",
          "code": "def test_example_function_mixed_positive_negative():\n    '''Test addition with mixed positive and negative integers'''\n    # Category: positive\n    result = example_function(5, -3)\n    assert result == 2, \"Should return the correct sum of mixed positive and negative integers\""
        },
        {
          "name": "test_example_function_boundary_large_numbers",
          "code": "def test_example_function_boundary_large_numbers():\n    '''Test addition with large numbers'''\n    # Category: boundary\n    result = example_function(10**9, 10**9)\n    assert result == 2 * 10**9, \"Should return the correct sum of large integers\""
        },
        {
          "name": "test_example_function_edge_case_max_int",
          "code": "def test_example_function_edge_case_max_int():\n    '''Test addition with the maximum integer value'''\n    # Category: edge_case\n    import sys\n    max_int = sys.maxsize\n    result = example_function(max_int, 1)\n    assert result == max_int + 1, \"Should return the correct sum when adding to max int (might overflow depending on system)\""
        },
        {
          "name": "test_example_function_negative_invalid_input_string",
          "code": "def test_example_function_negative_invalid_input_string():\n    '''Test addition with string inputs'''\n    # Category: negative\n    with pytest.raises(TypeError):\n        example_function(\"a\", 1)"
        },
        {
          "name": "test_example_function_negative_invalid_input_float",
          "code": "def test_example_function_negative_invalid_input_float():\n    '''Test addition with float inputs'''\n    # Category: negative\n    result = example_function(2.5, 3.5)\n    assert result == 6.0, \"Should handle float inputs correctly\"\n```"
        }
      ],
      "test_count": 8
    },
    "gpt-5-mini": {
      "raw_response": "import pytest\nimport sys\n\n# Try to import example_function from the target module; if not available,\n# fall back to a local definition so these tests are self-contained.\ntry:\n    from example_module import example_function  # replace example_module with actual module name when available\nexcept Exception:\n    def example_function(x, y):\n        \"\"\"\n        Add two numbers together\n        \n        Args:\n            x (int): First number\n            y (int): Second number\n            \n        Returns:\n            int: Sum of x and y\n        \"\"\"\n        return x + y\n\n\ndef test_example_function_positive_integers():\n    \"\"\"Test normal functionality with two positive integers\"\"\"\n    # Category: positive\n    result = example_function(2, 3)\n    assert result == 5, f\"Expected 2 + 3 to equal 5, got {result}\"\n    assert isinstance(result, int), f\"Expected result type int for integer inputs, got {type(result)}\"\n\n\ndef test_example_function_positive_mixed_float_and_int():\n    \"\"\"Test addition of int and float returns correct numeric sum and a float type\"\"\"\n    # Category: positive\n    result = example_function(2, 3.5)\n    assert result == 5.5, f\"Expected 2 + 3.5 to equal 5.5, got {result}\"\n    assert isinstance(result, float), f\"Expected result type float when mixing int and float, got {type(result)}\"\n\n\ndef test_example_function_negative_and_zero_boundary():\n    \"\"\"Test boundary values including zero and negative numbers\"\"\"\n    # Category: boundary\n    assert example_function(0, 0) == 0, \"0 + 0 should be 0\"\n    assert example_function(-1, -2) == -3, \"-1 + -2 should be -3\"\n    assert example_function(-5, 5) == 0, \"-5 + 5 should be 0\"\n\n\ndef test_example_function_large_integers_edge_case_no_overflow():\n    \"\"\"Test extremely large integers — Python supports arbitrary precision so no overflow expected\"\"\"\n    # Category: edge_case\n    a = 10**100  # very large integer\n    b = 10**100 + 1\n    expected = a + b\n    result = example_function(a, b)\n    assert result == expected, \"Summing very large integers should produce the mathematically correct result\"\n    assert isinstance(result, int), \"Result of adding two ints should remain an int even if very large\"\n\n\ndef test_example_function_invalid_none_raises_typeerror():\n    \"\"\"Passing None is not supported; addition should raise a TypeError\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError):\n        _ = example_function(None, 1)\n\n\ndef test_example_function_string_inputs_concatenate_unexpected_behavior():\n    \"\"\"If strings are passed, Python will concatenate them — this is not consistent with the documented int contract\"\"\"\n    # Category: negative\n    result = example_function(\"a\", \"b\")\n    assert result == \"ab\", f\"String inputs should concatenate; expected 'ab', got {result}\"\n    assert isinstance(result, str), \"When passing strings, result will be a str (not an int) which violates the documented contract\"\n\n\ndef test_example_function_custom_object_without_add_raises_typeerror():\n    \"\"\"Objects that do not support addition with ints should cause a TypeError\"\"\"\n    # Category: error_handling\n    class NoAdd:\n        pass\n\n    with pytest.raises(TypeError):\n        _ = example_function(NoAdd(), 1)\n\n\ndef test_example_function_custom_add_raises_propagates_exception_security():\n    \"\"\"If a custom object's __add__ raises an exception, it should propagate — test for that behavior\"\"\"\n    # Category: security\n    class MaliciousAdd:\n        def __init__(self, msg=\"boom\"):\n            self.msg = msg\n        def __add__(self, other):\n            raise RuntimeError(self.msg)\n\n    with pytest.raises(RuntimeError) as excinfo:\n        _ = example_function(MaliciousAdd(\"exploit\"), 1)\n    assert \"exploit\" in str(excinfo.value), \"Exceptions raised in user-defined __add__ should propagate unchanged\"",
      "test_methods": [
        {
          "name": "test_example_function_positive_integers",
          "code": "def test_example_function_positive_integers():\n    \"\"\"Test normal functionality with two positive integers\"\"\"\n    # Category: positive\n    result = example_function(2, 3)\n    assert result == 5, f\"Expected 2 + 3 to equal 5, got {result}\"\n    assert isinstance(result, int), f\"Expected result type int for integer inputs, got {type(result)}\""
        },
        {
          "name": "test_example_function_positive_mixed_float_and_int",
          "code": "def test_example_function_positive_mixed_float_and_int():\n    \"\"\"Test addition of int and float returns correct numeric sum and a float type\"\"\"\n    # Category: positive\n    result = example_function(2, 3.5)\n    assert result == 5.5, f\"Expected 2 + 3.5 to equal 5.5, got {result}\"\n    assert isinstance(result, float), f\"Expected result type float when mixing int and float, got {type(result)}\""
        },
        {
          "name": "test_example_function_negative_and_zero_boundary",
          "code": "def test_example_function_negative_and_zero_boundary():\n    \"\"\"Test boundary values including zero and negative numbers\"\"\"\n    # Category: boundary\n    assert example_function(0, 0) == 0, \"0 + 0 should be 0\"\n    assert example_function(-1, -2) == -3, \"-1 + -2 should be -3\"\n    assert example_function(-5, 5) == 0, \"-5 + 5 should be 0\""
        },
        {
          "name": "test_example_function_large_integers_edge_case_no_overflow",
          "code": "def test_example_function_large_integers_edge_case_no_overflow():\n    \"\"\"Test extremely large integers — Python supports arbitrary precision so no overflow expected\"\"\"\n    # Category: edge_case\n    a = 10**100  # very large integer\n    b = 10**100 + 1\n    expected = a + b\n    result = example_function(a, b)\n    assert result == expected, \"Summing very large integers should produce the mathematically correct result\"\n    assert isinstance(result, int), \"Result of adding two ints should remain an int even if very large\""
        },
        {
          "name": "test_example_function_invalid_none_raises_typeerror",
          "code": "def test_example_function_invalid_none_raises_typeerror():\n    \"\"\"Passing None is not supported; addition should raise a TypeError\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError):\n        _ = example_function(None, 1)"
        },
        {
          "name": "test_example_function_string_inputs_concatenate_unexpected_behavior",
          "code": "def test_example_function_string_inputs_concatenate_unexpected_behavior():\n    \"\"\"If strings are passed, Python will concatenate them — this is not consistent with the documented int contract\"\"\"\n    # Category: negative\n    result = example_function(\"a\", \"b\")\n    assert result == \"ab\", f\"String inputs should concatenate; expected 'ab', got {result}\"\n    assert isinstance(result, str), \"When passing strings, result will be a str (not an int) which violates the documented contract\""
        },
        {
          "name": "test_example_function_custom_object_without_add_raises_typeerror",
          "code": "def test_example_function_custom_object_without_add_raises_typeerror():\n    \"\"\"Objects that do not support addition with ints should cause a TypeError\"\"\"\n    # Category: error_handling\n    class NoAdd:\n        pass\n\n    with pytest.raises(TypeError):\n        _ = example_function(NoAdd(), 1)"
        },
        {
          "name": "test_example_function_custom_add_raises_propagates_exception_security",
          "code": "def test_example_function_custom_add_raises_propagates_exception_security():\n    \"\"\"If a custom object's __add__ raises an exception, it should propagate — test for that behavior\"\"\"\n    # Category: security\n    class MaliciousAdd:\n        def __init__(self, msg=\"boom\"):\n            self.msg = msg\n        def __add__(self, other):\n            raise RuntimeError(self.msg)\n\n    with pytest.raises(RuntimeError) as excinfo:\n        _ = example_function(MaliciousAdd(\"exploit\"), 1)\n    assert \"exploit\" in str(excinfo.value), \"Exceptions raised in user-defined __add__ should propagate unchanged\""
        }
      ],
      "test_count": 8
    },
    "grok-3-mini": {
      "raw_response": "```python\nimport pytest\nimport sys  # For boundary tests involving max int\n\n# Assuming example_function is in the same module or imported from another module\n# from your_module import example_function  # Uncomment and adjust if needed\n\ndef test_example_function_positive_addition():\n    \"\"\"\n    Test normal functionality with two positive integers.\n    \"\"\"\n    # Category: positive\n    result = example_function(2, 3)\n    assert result == 5, \"Should correctly add two positive integers\"\n\ndef test_example_function_positive_negative_numbers():\n    \"\"\"\n    Test normal functionality with two negative integers.\n    \"\"\"\n    # Category: positive\n    result = example_function(-4, -5)\n    assert result == -9, \"Should correctly add two negative integers\"\n\ndef test_example_function_boundary_zero():\n    \"\"\"\n    Test boundary condition with zero as one of the inputs.\n    \"\"\"\n    # Category: boundary\n    result = example_function(0, 5)\n    assert result == 5, \"Should correctly handle addition with zero\"\n\ndef test_example_function_boundary_max_int():\n    \"\"\"\n    Test boundary condition with the maximum integer value.\n    \"\"\"\n    # Category: boundary\n    max_int_value = sys.maxsize\n    result = example_function(max_int_value, 0)\n    assert result == max_int_value, \"Should correctly handle addition with the maximum integer value without overflow (Python handles large ints)\"\n\ndef test_example_function_edge_case_mixed_signs():\n    \"\"\"\n    Test edge case with one positive and one negative integer.\n    \"\"\"\n    # Category: edge_case\n    result = example_function(100, -50)\n    assert result == 50, \"Should correctly handle addition of mixed sign integers\"\n\ndef test_example_function_edge_case_large_numbers():\n    \"\"\"\n    Test edge case with very large integers.\n    \"\"\"\n    # Category: edge_case\n    large_number = 10**12  # A very large integer\n    result = example_function(large_number, 1)\n    assert result == large_number + 1, \"Should correctly handle addition of very large integers\"\n\ndef test_example_function_negative_non_int_string():\n    \"\"\"\n    Test negative case with a non-integer input (string) and expect a TypeError.\n    \"\"\"\n    # Category: negative\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        example_function(\"a\", 1)  # Expect TypeError because string and int cannot be added\n\ndef test_example_function_negative_float_input():\n    \"\"\"\n    Test negative case with a float input, which violates the function's expected int type.\n    Note: The function does not enforce type checking, so it will perform addition but return a float.\n    We assert that it does not behave as expected for ints.\n    \"\"\"\n    # Category: negative\n    result = example_function(1.5, 2)  # This will return 3.5, but docstring specifies ints\n    assert isinstance(result, float), \"Should return a float when a float is passed, indicating invalid input handling\"\n    # Additionally, we can check that it's not the expected int behavior\n    assert result != 3, \"The result should not match integer addition due to type mismatch\"\n    \n# Total of 8 tests, focusing on quality and coverage as per requirements.\n# These tests cover positive scenarios, boundary values, edge cases, and negative/error handling.\n# Security considerations: For this simple function, there are no apparent security risks like injections,\n# but we've indirectly covered potential issues with invalid inputs that could lead to unexpected behavior.\n``` \n\n### Explanation of the Generated Tests:\n- **Total Tests**: 8 (as requested, between 5-10, with a focus on quality and coverage).\n- **Categories Used**: \n  - Positive: Tests normal, expected usage.\n  - Boundary: Tests edge values like zero or system limits.\n  - Edge Case: Tests less common but valid scenarios, like mixed signs or very large numbers.\n  - Negative: Tests invalid inputs and verifies error conditions.\n- **Diversity and Coverage**:\n  - **Positive Cases**: Cover typical usage with positive and negative integers.\n  - **Boundary Cases**: Include zero and the maximum integer to check limits.\n  - **Edge Cases**: Include mixed signs and very large numbers to ensure robustness.\n  - **Negative Cases**: Test invalid inputs (e.g., strings, floats) and use `pytest.raises` for expected errors. For floats, we don't get a TypeError (as Python allows it), so we assert on the unexpected output type to highlight the mismatch with the function's documentation.\n  - **Error Handling**: Assertions include meaningful messages, and we use `pytest.raises` for scenarios where errors are expected.\n  - **Security**: Not directly applicable here, as the function is a simple addition. However, negative tests indirectly address potential security concerns by ensuring invalid inputs don't lead to silent failures or unexpected behavior.\n\nThis set provides comprehensive coverage without redundancy, ensuring the function is tested thoroughly.",
      "test_methods": [
        {
          "name": "test_example_function_positive_addition",
          "code": "def test_example_function_positive_addition():\n    \"\"\"\n    Test normal functionality with two positive integers.\n    \"\"\"\n    # Category: positive\n    result = example_function(2, 3)\n    assert result == 5, \"Should correctly add two positive integers\""
        },
        {
          "name": "test_example_function_positive_negative_numbers",
          "code": "def test_example_function_positive_negative_numbers():\n    \"\"\"\n    Test normal functionality with two negative integers.\n    \"\"\"\n    # Category: positive\n    result = example_function(-4, -5)\n    assert result == -9, \"Should correctly add two negative integers\""
        },
        {
          "name": "test_example_function_boundary_zero",
          "code": "def test_example_function_boundary_zero():\n    \"\"\"\n    Test boundary condition with zero as one of the inputs.\n    \"\"\"\n    # Category: boundary\n    result = example_function(0, 5)\n    assert result == 5, \"Should correctly handle addition with zero\""
        },
        {
          "name": "test_example_function_boundary_max_int",
          "code": "def test_example_function_boundary_max_int():\n    \"\"\"\n    Test boundary condition with the maximum integer value.\n    \"\"\"\n    # Category: boundary\n    max_int_value = sys.maxsize\n    result = example_function(max_int_value, 0)\n    assert result == max_int_value, \"Should correctly handle addition with the maximum integer value without overflow (Python handles large ints)\""
        },
        {
          "name": "test_example_function_edge_case_mixed_signs",
          "code": "def test_example_function_edge_case_mixed_signs():\n    \"\"\"\n    Test edge case with one positive and one negative integer.\n    \"\"\"\n    # Category: edge_case\n    result = example_function(100, -50)\n    assert result == 50, \"Should correctly handle addition of mixed sign integers\""
        },
        {
          "name": "test_example_function_edge_case_large_numbers",
          "code": "def test_example_function_edge_case_large_numbers():\n    \"\"\"\n    Test edge case with very large integers.\n    \"\"\"\n    # Category: edge_case\n    large_number = 10**12  # A very large integer\n    result = example_function(large_number, 1)\n    assert result == large_number + 1, \"Should correctly handle addition of very large integers\""
        },
        {
          "name": "test_example_function_negative_non_int_string",
          "code": "def test_example_function_negative_non_int_string():\n    \"\"\"\n    Test negative case with a non-integer input (string) and expect a TypeError.\n    \"\"\"\n    # Category: negative\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        example_function(\"a\", 1)  # Expect TypeError because string and int cannot be added"
        },
        {
          "name": "test_example_function_negative_float_input",
          "code": "def test_example_function_negative_float_input():\n    \"\"\"\n    Test negative case with a float input, which violates the function's expected int type.\n    Note: The function does not enforce type checking, so it will perform addition but return a float.\n    We assert that it does not behave as expected for ints.\n    \"\"\"\n    # Category: negative\n    result = example_function(1.5, 2)  # This will return 3.5, but docstring specifies ints\n    assert isinstance(result, float), \"Should return a float when a float is passed, indicating invalid input handling\"\n    # Additionally, we can check that it's not the expected int behavior\n    assert result != 3, \"The result should not match integer addition due to type mismatch\"\n    \n# Total of 8 tests, focusing on quality and coverage as per requirements.\n# These tests cover positive scenarios, boundary values, edge cases, and negative/error handling.\n# Security considerations: For this simple function, there are no apparent security risks like injections,\n# but we've indirectly covered potential issues with invalid inputs that could lead to unexpected behavior.\n``` \n\n### Explanation of the Generated Tests:\n- **Total Tests**: 8 (as requested, between 5-10, with a focus on quality and coverage).\n- **Categories Used**: \n  - Positive: Tests normal, expected usage.\n  - Boundary: Tests edge values like zero or system limits.\n  - Edge Case: Tests less common but valid scenarios, like mixed signs or very large numbers.\n  - Negative: Tests invalid inputs and verifies error conditions.\n- **Diversity and Coverage**:\n  - **Positive Cases**: Cover typical usage with positive and negative integers.\n  - **Boundary Cases**: Include zero and the maximum integer to check limits.\n  - **Edge Cases**: Include mixed signs and very large numbers to ensure robustness.\n  - **Negative Cases**: Test invalid inputs (e.g., strings, floats) and use `pytest.raises` for expected errors. For floats, we don't get a TypeError (as Python allows it), so we assert on the unexpected output type to highlight the mismatch with the function's documentation.\n  - **Error Handling**: Assertions include meaningful messages, and we use `pytest.raises` for scenarios where errors are expected.\n  - **Security**: Not directly applicable here, as the function is a simple addition. However, negative tests indirectly address potential security concerns by ensuring invalid inputs don't lead to silent failures or unexpected behavior.\n\nThis set provides comprehensive coverage without redundancy, ensuring the function is tested thoroughly."
        }
      ],
      "test_count": 8
    }
  },
  "all_classified_tests": [
    {
      "name": "test_example_function_positive_normal",
      "code": "def test_example_function_positive_normal():\n    '''Test normal addition with positive integers'''\n    # Category: positive\n    result = example_function(5, 3)\n    assert result == 8, \"Should return the correct sum of positive integers\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_example_function_positive_zero",
      "code": "def test_example_function_positive_zero():\n    '''Test addition with zero'''\n    # Category: edge_case\n    result = example_function(5, 0)\n    assert result == 5, \"Should return the first number when the second is zero\"",
      "category": "edge_case",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_example_function_negative_normal",
      "code": "def test_example_function_negative_normal():\n    '''Test addition with negative integers'''\n    # Category: positive\n    result = example_function(-5, -3)\n    assert result == -8, \"Should return the correct sum of negative integers\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_example_function_mixed_positive_negative",
      "code": "def test_example_function_mixed_positive_negative():\n    '''Test addition with mixed positive and negative integers'''\n    # Category: positive\n    result = example_function(5, -3)\n    assert result == 2, \"Should return the correct sum of mixed positive and negative integers\"",
      "category": "positive",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_example_function_boundary_large_numbers",
      "code": "def test_example_function_boundary_large_numbers():\n    '''Test addition with large numbers'''\n    # Category: boundary\n    result = example_function(10**9, 10**9)\n    assert result == 2 * 10**9, \"Should return the correct sum of large integers\"",
      "category": "boundary",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_example_function_edge_case_max_int",
      "code": "def test_example_function_edge_case_max_int():\n    '''Test addition with the maximum integer value'''\n    # Category: edge_case\n    import sys\n    max_int = sys.maxsize\n    result = example_function(max_int, 1)\n    assert result == max_int + 1, \"Should return the correct sum when adding to max int (might overflow depending on system)\"",
      "category": "edge_case",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_example_function_negative_invalid_input_string",
      "code": "def test_example_function_negative_invalid_input_string():\n    '''Test addition with string inputs'''\n    # Category: negative\n    with pytest.raises(TypeError):\n        example_function(\"a\", 1)",
      "category": "negative",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_example_function_negative_invalid_input_float",
      "code": "def test_example_function_negative_invalid_input_float():\n    '''Test addition with float inputs'''\n    # Category: negative\n    result = example_function(2.5, 3.5)\n    assert result == 6.0, \"Should handle float inputs correctly\"\n```",
      "category": "negative",
      "source_model": "gemini-2.0-flash"
    },
    {
      "name": "test_example_function_positive_integers",
      "code": "def test_example_function_positive_integers():\n    \"\"\"Test normal functionality with two positive integers\"\"\"\n    # Category: positive\n    result = example_function(2, 3)\n    assert result == 5, f\"Expected 2 + 3 to equal 5, got {result}\"\n    assert isinstance(result, int), f\"Expected result type int for integer inputs, got {type(result)}\"",
      "category": "positive",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_example_function_positive_mixed_float_and_int",
      "code": "def test_example_function_positive_mixed_float_and_int():\n    \"\"\"Test addition of int and float returns correct numeric sum and a float type\"\"\"\n    # Category: positive\n    result = example_function(2, 3.5)\n    assert result == 5.5, f\"Expected 2 + 3.5 to equal 5.5, got {result}\"\n    assert isinstance(result, float), f\"Expected result type float when mixing int and float, got {type(result)}\"",
      "category": "positive",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_example_function_negative_and_zero_boundary",
      "code": "def test_example_function_negative_and_zero_boundary():\n    \"\"\"Test boundary values including zero and negative numbers\"\"\"\n    # Category: boundary\n    assert example_function(0, 0) == 0, \"0 + 0 should be 0\"\n    assert example_function(-1, -2) == -3, \"-1 + -2 should be -3\"\n    assert example_function(-5, 5) == 0, \"-5 + 5 should be 0\"",
      "category": "boundary",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_example_function_large_integers_edge_case_no_overflow",
      "code": "def test_example_function_large_integers_edge_case_no_overflow():\n    \"\"\"Test extremely large integers — Python supports arbitrary precision so no overflow expected\"\"\"\n    # Category: edge_case\n    a = 10**100  # very large integer\n    b = 10**100 + 1\n    expected = a + b\n    result = example_function(a, b)\n    assert result == expected, \"Summing very large integers should produce the mathematically correct result\"\n    assert isinstance(result, int), \"Result of adding two ints should remain an int even if very large\"",
      "category": "edge_case",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_example_function_invalid_none_raises_typeerror",
      "code": "def test_example_function_invalid_none_raises_typeerror():\n    \"\"\"Passing None is not supported; addition should raise a TypeError\"\"\"\n    # Category: negative\n    with pytest.raises(TypeError):\n        _ = example_function(None, 1)",
      "category": "negative",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_example_function_string_inputs_concatenate_unexpected_behavior",
      "code": "def test_example_function_string_inputs_concatenate_unexpected_behavior():\n    \"\"\"If strings are passed, Python will concatenate them — this is not consistent with the documented int contract\"\"\"\n    # Category: negative\n    result = example_function(\"a\", \"b\")\n    assert result == \"ab\", f\"String inputs should concatenate; expected 'ab', got {result}\"\n    assert isinstance(result, str), \"When passing strings, result will be a str (not an int) which violates the documented contract\"",
      "category": "negative",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_example_function_custom_object_without_add_raises_typeerror",
      "code": "def test_example_function_custom_object_without_add_raises_typeerror():\n    \"\"\"Objects that do not support addition with ints should cause a TypeError\"\"\"\n    # Category: error_handling\n    class NoAdd:\n        pass\n\n    with pytest.raises(TypeError):\n        _ = example_function(NoAdd(), 1)",
      "category": "negative",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_example_function_custom_add_raises_propagates_exception_security",
      "code": "def test_example_function_custom_add_raises_propagates_exception_security():\n    \"\"\"If a custom object's __add__ raises an exception, it should propagate — test for that behavior\"\"\"\n    # Category: security\n    class MaliciousAdd:\n        def __init__(self, msg=\"boom\"):\n            self.msg = msg\n        def __add__(self, other):\n            raise RuntimeError(self.msg)\n\n    with pytest.raises(RuntimeError) as excinfo:\n        _ = example_function(MaliciousAdd(\"exploit\"), 1)\n    assert \"exploit\" in str(excinfo.value), \"Exceptions raised in user-defined __add__ should propagate unchanged\"",
      "category": "security",
      "source_model": "gpt-5-mini"
    },
    {
      "name": "test_example_function_positive_addition",
      "code": "def test_example_function_positive_addition():\n    \"\"\"\n    Test normal functionality with two positive integers.\n    \"\"\"\n    # Category: positive\n    result = example_function(2, 3)\n    assert result == 5, \"Should correctly add two positive integers\"",
      "category": "positive",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_example_function_positive_negative_numbers",
      "code": "def test_example_function_positive_negative_numbers():\n    \"\"\"\n    Test normal functionality with two negative integers.\n    \"\"\"\n    # Category: positive\n    result = example_function(-4, -5)\n    assert result == -9, \"Should correctly add two negative integers\"",
      "category": "positive",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_example_function_boundary_zero",
      "code": "def test_example_function_boundary_zero():\n    \"\"\"\n    Test boundary condition with zero as one of the inputs.\n    \"\"\"\n    # Category: boundary\n    result = example_function(0, 5)\n    assert result == 5, \"Should correctly handle addition with zero\"",
      "category": "boundary",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_example_function_boundary_max_int",
      "code": "def test_example_function_boundary_max_int():\n    \"\"\"\n    Test boundary condition with the maximum integer value.\n    \"\"\"\n    # Category: boundary\n    max_int_value = sys.maxsize\n    result = example_function(max_int_value, 0)\n    assert result == max_int_value, \"Should correctly handle addition with the maximum integer value without overflow (Python handles large ints)\"",
      "category": "boundary",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_example_function_edge_case_mixed_signs",
      "code": "def test_example_function_edge_case_mixed_signs():\n    \"\"\"\n    Test edge case with one positive and one negative integer.\n    \"\"\"\n    # Category: edge_case\n    result = example_function(100, -50)\n    assert result == 50, \"Should correctly handle addition of mixed sign integers\"",
      "category": "edge_case",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_example_function_edge_case_large_numbers",
      "code": "def test_example_function_edge_case_large_numbers():\n    \"\"\"\n    Test edge case with very large integers.\n    \"\"\"\n    # Category: edge_case\n    large_number = 10**12  # A very large integer\n    result = example_function(large_number, 1)\n    assert result == large_number + 1, \"Should correctly handle addition of very large integers\"",
      "category": "edge_case",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_example_function_negative_non_int_string",
      "code": "def test_example_function_negative_non_int_string():\n    \"\"\"\n    Test negative case with a non-integer input (string) and expect a TypeError.\n    \"\"\"\n    # Category: negative\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        example_function(\"a\", 1)  # Expect TypeError because string and int cannot be added",
      "category": "negative",
      "source_model": "grok-3-mini"
    },
    {
      "name": "test_example_function_negative_float_input",
      "code": "def test_example_function_negative_float_input():\n    \"\"\"\n    Test negative case with a float input, which violates the function's expected int type.\n    Note: The function does not enforce type checking, so it will perform addition but return a float.\n    We assert that it does not behave as expected for ints.\n    \"\"\"\n    # Category: negative\n    result = example_function(1.5, 2)  # This will return 3.5, but docstring specifies ints\n    assert isinstance(result, float), \"Should return a float when a float is passed, indicating invalid input handling\"\n    # Additionally, we can check that it's not the expected int behavior\n    assert result != 3, \"The result should not match integer addition due to type mismatch\"\n    \n# Total of 8 tests, focusing on quality and coverage as per requirements.\n# These tests cover positive scenarios, boundary values, edge cases, and negative/error handling.\n# Security considerations: For this simple function, there are no apparent security risks like injections,\n# but we've indirectly covered potential issues with invalid inputs that could lead to unexpected behavior.\n``` \n\n### Explanation of the Generated Tests:\n- **Total Tests**: 8 (as requested, between 5-10, with a focus on quality and coverage).\n- **Categories Used**: \n  - Positive: Tests normal, expected usage.\n  - Boundary: Tests edge values like zero or system limits.\n  - Edge Case: Tests less common but valid scenarios, like mixed signs or very large numbers.\n  - Negative: Tests invalid inputs and verifies error conditions.\n- **Diversity and Coverage**:\n  - **Positive Cases**: Cover typical usage with positive and negative integers.\n  - **Boundary Cases**: Include zero and the maximum integer to check limits.\n  - **Edge Cases**: Include mixed signs and very large numbers to ensure robustness.\n  - **Negative Cases**: Test invalid inputs (e.g., strings, floats) and use `pytest.raises` for expected errors. For floats, we don't get a TypeError (as Python allows it), so we assert on the unexpected output type to highlight the mismatch with the function's documentation.\n  - **Error Handling**: Assertions include meaningful messages, and we use `pytest.raises` for scenarios where errors are expected.\n  - **Security**: Not directly applicable here, as the function is a simple addition. However, negative tests indirectly address potential security concerns by ensuring invalid inputs don't lead to silent failures or unexpected behavior.\n\nThis set provides comprehensive coverage without redundancy, ensuring the function is tested thoroughly.",
      "category": "negative",
      "source_model": "grok-3-mini"
    }
  ],
  "synthesis_results": {
    "final_tests": [
      {
        "name": "test_positive_integers",
        "code": "def test_positive_integers():\n        \"\"\"Test normal addition with positive integers.\"\"\"\n        result = example_function(2, 3)\n        assert result == 5, f\"Expected 2 + 3 to equal 5, got {result}\"\n        assert isinstance(result, int), f\"Expected result type int for integer inputs, got {type(result)}\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_negative_integers",
        "code": "def test_negative_integers():\n        \"\"\"Test addition with negative integers.\"\"\"\n        result = example_function(-5, -3)\n        assert result == -8, \"Should return the correct sum of negative integers\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_mixed_positive_negative",
        "code": "def test_mixed_positive_negative():\n        \"\"\"Test addition with mixed positive and negative integers.\"\"\"\n        result = example_function(5, -3)\n        assert result == 2, \"Should return the correct sum of mixed positive and negative integers\"\n\n\n# Boundary Tests\nclass TestBoundary:\n    \"\"\"Tests for boundary conditions.\"\"\"",
        "category": "boundary",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_addition_with_zero",
        "code": "def test_addition_with_zero():\n        \"\"\"Test addition with zero as one of the inputs.\"\"\"\n        result = example_function(0, 5)\n        assert result == 5, \"Should correctly handle addition with zero\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_large_numbers",
        "code": "def test_large_numbers():\n        \"\"\"Test addition with large numbers.\"\"\"\n        large_number = 10**12\n        result = example_function(large_number, 1)\n        assert result == large_number + 1, \"Should correctly handle addition of very large integers\"",
        "category": "positive",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_max_int_value",
        "code": "def test_max_int_value():\n        \"\"\"Test boundary condition with the maximum integer value.\"\"\"\n        max_int_value = sys.maxsize\n        result = example_function(max_int_value, 0)\n        assert result == max_int_value, \"Should correctly handle addition with the maximum integer value without overflow (Python handles large ints)\"\n\n\n# Edge Case Tests\nclass TestEdgeCases:\n    \"\"\"Tests for edge case scenarios.\"\"\"",
        "category": "boundary",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_large_integers_no_overflow",
        "code": "def test_large_integers_no_overflow():\n        \"\"\"Test extremely large integers — Python supports arbitrary precision so no overflow expected.\"\"\"\n        a = 10**100  # very large integer\n        b = 10**100 + 1\n        expected = a + b\n        result = example_function(a, b)\n        assert result == expected, \"Summing very large integers should produce the mathematically correct result\"\n        assert isinstance(result, int), \"Result of adding two ints should remain an int even if very large\"\n\n\n# Negative Tests\nclass TestNegative:\n    \"\"\"Tests for invalid input and error conditions.\"\"\"",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_invalid_input_string",
        "code": "def test_invalid_input_string():\n        \"\"\"Test addition with string inputs and expect a TypeError.\"\"\"\n        with pytest.raises(TypeError, match=\"unsupported operand type\"):\n            example_function(\"a\", 1)  # Expect TypeError because string and int cannot be added",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_float_input",
        "code": "def test_float_input():\n        \"\"\"Test with float input, which violates the function's expected int type.\"\"\"\n        result = example_function(1.5, 2)\n        assert isinstance(result, float), \"Should return a float when a float is passed, indicating invalid input handling\"\n        assert result != 3, \"The result should not match integer addition due to type mismatch\"",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_none_raises_typeerror",
        "code": "def test_none_raises_typeerror():\n        \"\"\"Passing None is not supported; addition should raise a TypeError.\"\"\"\n        with pytest.raises(TypeError):\n            _ = example_function(None, 1)\n\n# Security Tests\nclass TestSecurity:\n    \"\"\"Tests for security related issues (e.g., exception propagation).\"\"\"",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      },
      {
        "name": "test_custom_add_raises_propagates_exception",
        "code": "def test_custom_add_raises_propagates_exception():\n        \"\"\"If a custom object's __add__ raises an exception, it should propagate.\"\"\"\n        class MaliciousAdd:\n            def __init__(self, msg=\"boom\"):\n                self.msg = msg\n            def __add__(self, other):\n                raise RuntimeError(self.msg)\n\n        with pytest.raises(RuntimeError) as excinfo:\n            _ = example_function(MaliciousAdd(\"exploit\"), 1)\n        assert \"exploit\" in str(excinfo.value), \"Exceptions raised in user-defined __add__ should propagate unchanged\"\n```",
        "category": "negative",
        "source": "synthesized",
        "original_sources": [
          "grok-3-mini",
          "gemini-2.0-flash",
          "gpt-5-mini"
        ]
      }
    ],
    "original_count": 24,
    "final_count": 11,
    "reduction_ratio": 0.5416666666666666,
    "synthesizer_model": "gemini-2.0-flash"
  },
  "final_test_file": "```python\n\"\"\"\nFinal optimized test suite for example_function.\n\nThis suite covers positive, negative, boundary, and edge cases\nto ensure comprehensive functionality and error handling.\n\"\"\"\n\nimport pytest\nimport sys\n\ndef example_function(x, y):\n    \"\"\"\n    Add two numbers together\n    \n    Args:\n        x (int): First number\n        y (int): Second number\n        \n    Returns:\n        int: Sum of x and y\n    \"\"\"\n    return x + y\n\n\n# Positive Tests\nclass TestPositive:\n    \"\"\"Tests for normal positive scenarios.\"\"\"\n\n    def test_positive_integers(self):\n        \"\"\"Test normal addition with positive integers.\"\"\"\n        result = example_function(2, 3)\n        assert result == 5, f\"Expected 2 + 3 to equal 5, got {result}\"\n        assert isinstance(result, int), f\"Expected result type int for integer inputs, got {type(result)}\"\n\n    def test_negative_integers(self):\n        \"\"\"Test addition with negative integers.\"\"\"\n        result = example_function(-5, -3)\n        assert result == -8, \"Should return the correct sum of negative integers\"\n\n    def test_mixed_positive_negative(self):\n        \"\"\"Test addition with mixed positive and negative integers.\"\"\"\n        result = example_function(5, -3)\n        assert result == 2, \"Should return the correct sum of mixed positive and negative integers\"\n\n\n# Boundary Tests\nclass TestBoundary:\n    \"\"\"Tests for boundary conditions.\"\"\"\n\n    def test_addition_with_zero(self):\n        \"\"\"Test addition with zero as one of the inputs.\"\"\"\n        result = example_function(0, 5)\n        assert result == 5, \"Should correctly handle addition with zero\"\n\n    def test_large_numbers(self):\n        \"\"\"Test addition with large numbers.\"\"\"\n        large_number = 10**12\n        result = example_function(large_number, 1)\n        assert result == large_number + 1, \"Should correctly handle addition of very large integers\"\n\n    def test_max_int_value(self):\n        \"\"\"Test boundary condition with the maximum integer value.\"\"\"\n        max_int_value = sys.maxsize\n        result = example_function(max_int_value, 0)\n        assert result == max_int_value, \"Should correctly handle addition with the maximum integer value without overflow (Python handles large ints)\"\n\n\n# Edge Case Tests\nclass TestEdgeCases:\n    \"\"\"Tests for edge case scenarios.\"\"\"\n\n    def test_large_integers_no_overflow(self):\n        \"\"\"Test extremely large integers — Python supports arbitrary precision so no overflow expected.\"\"\"\n        a = 10**100  # very large integer\n        b = 10**100 + 1\n        expected = a + b\n        result = example_function(a, b)\n        assert result == expected, \"Summing very large integers should produce the mathematically correct result\"\n        assert isinstance(result, int), \"Result of adding two ints should remain an int even if very large\"\n\n\n# Negative Tests\nclass TestNegative:\n    \"\"\"Tests for invalid input and error conditions.\"\"\"\n\n    def test_invalid_input_string(self):\n        \"\"\"Test addition with string inputs and expect a TypeError.\"\"\"\n        with pytest.raises(TypeError, match=\"unsupported operand type\"):\n            example_function(\"a\", 1)  # Expect TypeError because string and int cannot be added\n\n    def test_float_input(self):\n        \"\"\"Test with float input, which violates the function's expected int type.\"\"\"\n        result = example_function(1.5, 2)\n        assert isinstance(result, float), \"Should return a float when a float is passed, indicating invalid input handling\"\n        assert result != 3, \"The result should not match integer addition due to type mismatch\"\n\n    def test_none_raises_typeerror(self):\n        \"\"\"Passing None is not supported; addition should raise a TypeError.\"\"\"\n        with pytest.raises(TypeError):\n            _ = example_function(None, 1)\n\n# Security Tests\nclass TestSecurity:\n    \"\"\"Tests for security related issues (e.g., exception propagation).\"\"\"\n\n    def test_custom_add_raises_propagates_exception(self):\n        \"\"\"If a custom object's __add__ raises an exception, it should propagate.\"\"\"\n        class MaliciousAdd:\n            def __init__(self, msg=\"boom\"):\n                self.msg = msg\n            def __add__(self, other):\n                raise RuntimeError(self.msg)\n\n        with pytest.raises(RuntimeError) as excinfo:\n            _ = example_function(MaliciousAdd(\"exploit\"), 1)\n        assert \"exploit\" in str(excinfo.value), \"Exceptions raised in user-defined __add__ should propagate unchanged\"\n```",
  "coverage_results": {
    "success": false,
    "stdout": "\u001b[1m============================= test session starts ==============================\u001b[0m\nplatform darwin -- Python 3.9.0, pytest-8.4.2, pluggy-1.6.0 -- /Users/sepehr/IdeaProjects/testgen-council/venv/bin/python\ncachedir: .pytest_cache\nrootdir: /var/folders/b8/8kbfnxhx3l34cnrh1tkx_y8h0000gn/T\nplugins: anyio-4.10.0, cov-7.0.0\n\u001b[1mcollecting ... \u001b[0mcollected 0 items / 1 error\n\n==================================== ERRORS ====================================\n\u001b[31m\u001b[1m_______________________ ERROR collecting tmpa6zmood5.py ________________________\u001b[0m\n\u001b[31m\u001b[1m\u001b[31mvenv/lib/python3.9/site-packages/_pytest/python.py\u001b[0m:498: in importtestmodule\n    \u001b[0mmod = import_path(\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mvenv/lib/python3.9/site-packages/_pytest/pathlib.py\u001b[0m:587: in import_path\n    \u001b[0mimportlib.import_module(module_name)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py\u001b[0m:127: in import_module\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m _bootstrap._gcd_import(name[level:], package, level)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m<frozen importlib._bootstrap>\u001b[0m:1030: in _gcd_import\n    \u001b[0m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m<frozen importlib._bootstrap>\u001b[0m:1007: in _find_and_load\n    \u001b[0m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m<frozen importlib._bootstrap>\u001b[0m:986: in _find_and_load_unlocked\n    \u001b[0m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m<frozen importlib._bootstrap>\u001b[0m:680: in _load_unlocked\n    \u001b[0m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[04m\u001b[91m?\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mvenv/lib/python3.9/site-packages/_pytest/assertion/rewrite.py\u001b[0m:177: in exec_module\n    \u001b[0msource_stat, co = _rewrite_test(fn, \u001b[96mself\u001b[39;49;00m.config)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mvenv/lib/python3.9/site-packages/_pytest/assertion/rewrite.py\u001b[0m:357: in _rewrite_test\n    \u001b[0mtree = ast.parse(source, filename=strfn)\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31m/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/ast.py\u001b[0m:50: in parse\n    \u001b[0m\u001b[94mreturn\u001b[39;49;00m \u001b[96mcompile\u001b[39;49;00m(source, filename, mode, flags,\u001b[90m\u001b[39;49;00m\n\u001b[1m\u001b[31mE     File \"/var/folders/b8/8kbfnxhx3l34cnrh1tkx_y8h0000gn/T/tmpa6zmood5.py\", line 5\u001b[0m\n\u001b[1m\u001b[31mE       ```python\u001b[0m\n\u001b[1m\u001b[31mE       ^\u001b[0m\n\u001b[1m\u001b[31mE   SyntaxError: invalid syntax\u001b[0m\u001b[0m\n\u001b[36m\u001b[1m=========================== short test summary info ============================\u001b[0m\n\u001b[31mERROR\u001b[0m ../../../../var/folders/b8/8kbfnxhx3l34cnrh1tkx_y8h0000gn/T/tmpa6zmood5.py\n!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!\n\u001b[31m=============================== \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.31s\u001b[0m\u001b[31m ===============================\u001b[0m\n",
    "stderr": "",
    "coverage_percentage": 85.0
  },
  "statistics": {
    "original_test_count": 24,
    "final_test_count": 11,
    "reduction_ratio": 0.5416666666666666,
    "coverage_percentage": 85.0,
    "models_used": [
      "gemini-2.0-flash",
      "gpt-5-mini",
      "grok-3-mini"
    ],
    "categories_found": [
      "positive",
      "edge_case",
      "boundary",
      "negative",
      "security"
    ],
    "synthesizer_model": "gemini-2.0-flash"
  }
}